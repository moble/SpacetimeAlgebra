/*

    Licensed under the  MIT license; see LICENSE file for full details.
    Copyright (c) 2014 Mike Boyle

*/

/*! \mainpage SpacetimeAlgebra documentation
 *
 * SpacetimeAlgebra implementation generated by Gaigen 2.5.
 *
 *
 * License:

    Licensed under the  MIT license; see LICENSE file for full details.
    Copyright (c) 2014 Mike Boyle

 *
 * \section intro_sec Introduction
 *
 * Todo
 *
 */
#ifndef _SPACETIMEALGEBRA_H_
#define _SPACETIMEALGEBRA_H_

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <string>
namespace SpacetimeAlgebra {

// group: 1
#define GROUP_0 1
// group: gamma_0, gamma_1, gamma_2, gamma_3
#define GROUP_1 2
// group: gamma_0^gamma_1, gamma_0^gamma_2, gamma_1^gamma_2, gamma_0^gamma_3, gamma_1^gamma_3, gamma_2^gamma_3
#define GROUP_2 4
// group: gamma_0^gamma_1^gamma_2, gamma_0^gamma_1^gamma_3, gamma_0^gamma_2^gamma_3, gamma_1^gamma_2^gamma_3
#define GROUP_3 8
// group: gamma_0^gamma_1^gamma_2^gamma_3
#define GROUP_4 16
#define GRADE_0 1
#define GRADE_1 2
#define GRADE_2 4
#define GRADE_3 8
#define GRADE_4 16


/// The dimension of the space:
extern const int SpacetimeAlgebra_spaceDim;

/// Number of groups/grades of coordinates in a multivector:
extern const int SpacetimeAlgebra_nbGroups;

/// The constants for the groups in an array:
extern const int SpacetimeAlgebra_groups[];

/// The constants for the grades in an array:
extern const int SpacetimeAlgebra_grades[];

/// Is the metric of the space Euclidean? (false or true)
extern const bool SpacetimeAlgebra_metricEuclidean;

/// This array can be used to lookup the number of coordinates for a group part of a general multivector
extern const int SpacetimeAlgebra_groupSize[5];

/// This array can be used to lookup the number of coordinates based on a group usage bitmap
extern const int SpacetimeAlgebra_mvSize[32];

/// This array of ASCIIZ strings contains the names of the basis vectors
extern const char *SpacetimeAlgebra_basisVectorNames[4];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'what basis vectors are in the basis element at position [x]?
extern const int SpacetimeAlgebra_basisElements[16][5];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate at index [x]'?
extern const double SpacetimeAlgebra_basisElementSignByIndex[16];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate of bitmap [x]'?
extern const double SpacetimeAlgebra_basisElementSignByBitmap[16];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'at what index do I find basis element [x] (x = basis vector bitmap)?'
extern const int SpacetimeAlgebra_basisElementIndexByBitmap[16];

/// This array of integers contains the indices of basis elements in the general multivector
/// Use it to answer: 'what basis element do I find at index [x]'?
extern const int SpacetimeAlgebra_basisElementBitmapByIndex[16];

/// This array of grade of each basis elements in the general multivector
/// Use it to answer: 'what is the grade of basis element bitmap [x]'?
extern const int SpacetimeAlgebra_basisElementGradeByBitmap[16];

/// This array of group of each basis elements in the general multivector
/// Use it to answer: 'what is the group of basis element bitmap [x]'?
extern const int SpacetimeAlgebra_basisElementGroupByBitmap[16];
class mv;
class gamma_0_t;
class gamma_1_t;
class gamma_2_t;
class gamma_3_t;
class I_t;
class I3_t;
class mv3;
class vector;
class vector3;
class bivector;
class bivector3;
class pseudovector;
class spinor;
class spinor3;

/**
This function alters the formatting of 'string()'.
'format' = NULL will give you back the default.
*/
void setStringFormat(const char *what, const char *format);

extern const char *string_fp; /* = \"%2.2f\" */
extern const char *string_start; /* = \"\" */
extern const char *string_end; /* = \"\" */
extern const char *string_mul; /* = \"*\" */
extern const char *string_wedge; /* = \"^\" */
extern const char *string_plus; /* = \" + \" */
extern const char *string_minus; /* = \" - \" */

const char *c_str(const mv &obj, char *str, int maxLength, const char *fp = NULL);
std::string toString(const mv &obj, const char *fp = NULL);

inline const char *c_str_f(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%f");}
inline const char *c_str_e(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%e");}
inline const char *c_str_e20(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%2.20e");}

inline std::string toString_f(const mv &obj) {return toString(obj, "%f");}
inline std::string toString_e(const mv &obj) {return toString(obj, "%e");}
inline std::string toString_e20(const mv &obj) {return toString(obj, "%2.20e");}




/// This class can hold a general multivector.
///
/// The coordinates are stored in type double.
///
/// There are 5 coordinate groups:
/// group 0:1  (grade 0).
/// group 1:gamma_0, gamma_1, gamma_2, gamma_3  (grade 1).
/// group 2:gamma_0^gamma_1, gamma_0^gamma_2, gamma_1^gamma_2, gamma_0^gamma_3, gamma_1^gamma_3, gamma_2^gamma_3  (grade 2).
/// group 3:gamma_0^gamma_1^gamma_2, gamma_0^gamma_1^gamma_3, gamma_0^gamma_2^gamma_3, gamma_1^gamma_2^gamma_3  (grade 3).
/// group 4:gamma_0^gamma_1^gamma_2^gamma_3  (grade 4).
///
/// 16 doubles are allocated inside the struct.
///
class mv
{

public:
  /// group/grade usage (a bitmap which specifies which groups/grades are stored in 'c', below).
  int m_gu;
  /// the coordinates
  double m_c[16];
public:

  /// Floating point type used by mv
  typedef double Float;

  /// Constructs a new mv with value 0.
  inline mv()  {set();}

  /// Copy constructor.
  inline mv(const mv&A)  {set(A);}


  /// Constructs a new mv with scalar value 'scalar'.
  inline mv(double scalar)  {set(scalar);}

  /// Constructs a new mv from compressed 'coordinates'.
  /// \param gu bitwise OR of the GRADEs or GROUPs that are non-zero.
  /// \param coordinates compressed coordinates.
  inline mv(int gu, const double *coordinates)  {set(gu, coordinates);}

  /// Converts a gamma_0_t to a mv.
  inline mv(const gamma_0_t&A)  {set(A);}
  /// Converts a gamma_1_t to a mv.
  inline mv(const gamma_1_t&A)  {set(A);}
  /// Converts a gamma_2_t to a mv.
  inline mv(const gamma_2_t&A)  {set(A);}
  /// Converts a gamma_3_t to a mv.
  inline mv(const gamma_3_t&A)  {set(A);}
  /// Converts a I_t to a mv.
  inline mv(const I_t&A)  {set(A);}
  /// Converts a I3_t to a mv.
  inline mv(const I3_t&A)  {set(A);}
  /// Converts a mv3 to a mv.
  inline mv(const mv3&A)  {set(A);}
  /// Converts a vector to a mv.
  inline mv(const vector&A)  {set(A);}
  /// Converts a vector3 to a mv.
  inline mv(const vector3&A)  {set(A);}
  /// Converts a bivector to a mv.
  inline mv(const bivector&A)  {set(A);}
  /// Converts a bivector3 to a mv.
  inline mv(const bivector3&A)  {set(A);}
  /// Converts a pseudovector to a mv.
  inline mv(const pseudovector&A)  {set(A);}
  /// Converts a spinor to a mv.
  inline mv(const spinor&A)  {set(A);}
  /// Converts a spinor3 to a mv.
  inline mv(const spinor3&A)  {set(A);}


  /// Assignment operator (mv).
  inline mv &operator=(const mv &A) {if (this != &A) {set(A);} return *this;}
  /// Assignment operator (double).
  inline mv &operator=(const double &scalar) {set(scalar); return *this;}


  /// Assignment operator (mv).
  inline mv &operator=(const gamma_0_t &A) {set(A); return *this;}
  /// Assignment operator (mv).
  inline mv &operator=(const gamma_1_t &A) {set(A); return *this;}
  /// Assignment operator (mv).
  inline mv &operator=(const gamma_2_t &A) {set(A); return *this;}
  /// Assignment operator (mv).
  inline mv &operator=(const gamma_3_t &A) {set(A); return *this;}
  /// Assignment operator (mv).
  inline mv &operator=(const I_t &A) {set(A); return *this;}
  /// Assignment operator (mv).
  inline mv &operator=(const I3_t &A) {set(A); return *this;}
  /// Assignment operator (mv).
  inline mv &operator=(const mv3 &A) {set(A); return *this;}
  /// Assignment operator (mv).
  inline mv &operator=(const vector &A) {set(A); return *this;}
  /// Assignment operator (mv).
  inline mv &operator=(const vector3 &A) {set(A); return *this;}
  /// Assignment operator (mv).
  inline mv &operator=(const bivector &A) {set(A); return *this;}
  /// Assignment operator (mv).
  inline mv &operator=(const bivector3 &A) {set(A); return *this;}
  /// Assignment operator (mv).
  inline mv &operator=(const pseudovector &A) {set(A); return *this;}
  /// Assignment operator (mv).
  inline mv &operator=(const spinor &A) {set(A); return *this;}
  /// Assignment operator (mv).
  inline mv &operator=(const spinor3 &A) {set(A); return *this;}

  /// Sets this mv to 0.
  void set();

  /// Copies the value of 'A' to this.
  void set(const mv &A);


  /// Sets this mv to scalar value 'scalar'.
  void set(double scalar);

  /// Sets this mv from compressed 'coordinates'.
  /// \param gu bitwise OR of the GRADEs or GROUPs that are non-zero.
  /// \param coordinates compressed coordinates.
  void set(int gu, const double *coordinates);

  /// Sets this mv to the value of gamma_0_t A
  void set(const gamma_0_t &A);
  /// Sets this mv to the value of gamma_1_t A
  void set(const gamma_1_t &A);
  /// Sets this mv to the value of gamma_2_t A
  void set(const gamma_2_t &A);
  /// Sets this mv to the value of gamma_3_t A
  void set(const gamma_3_t &A);
  /// Sets this mv to the value of I_t A
  void set(const I_t &A);
  /// Sets this mv to the value of I3_t A
  void set(const I3_t &A);
  /// Sets this mv to the value of mv3 A
  void set(const mv3 &A);
  /// Sets this mv to the value of vector A
  void set(const vector &A);
  /// Sets this mv to the value of vector3 A
  void set(const vector3 &A);
  /// Sets this mv to the value of bivector A
  void set(const bivector &A);
  /// Sets this mv to the value of bivector3 A
  void set(const bivector3 &A);
  /// Sets this mv to the value of pseudovector A
  void set(const pseudovector &A);
  /// Sets this mv to the value of spinor A
  void set(const spinor &A);
  /// Sets this mv to the value of spinor3 A
  void set(const spinor3 &A);
  /// Returns the scalar coordinate of this mv.
  inline double get_scalar() const {
    return (m_gu & 1) ? m_c[SpacetimeAlgebra_mvSize[m_gu & 0] + 0] : 0.0;
  }
  /// Returns the gamma_0 coordinate of this mv.
  inline double get_gamma_0() const {
    return (m_gu & 2) ? m_c[SpacetimeAlgebra_mvSize[m_gu & 1] + 0] : 0.0;
  }
  /// Returns the gamma_1 coordinate of this mv.
  inline double get_gamma_1() const {
    return (m_gu & 2) ? m_c[SpacetimeAlgebra_mvSize[m_gu & 1] + 1] : 0.0;
  }
  /// Returns the gamma_2 coordinate of this mv.
  inline double get_gamma_2() const {
    return (m_gu & 2) ? m_c[SpacetimeAlgebra_mvSize[m_gu & 1] + 2] : 0.0;
  }
  /// Returns the gamma_3 coordinate of this mv.
  inline double get_gamma_3() const {
    return (m_gu & 2) ? m_c[SpacetimeAlgebra_mvSize[m_gu & 1] + 3] : 0.0;
  }
  /// Returns the gamma_0_gamma_1 coordinate of this mv.
  inline double get_gamma_0_gamma_1() const {
    return (m_gu & 4) ? m_c[SpacetimeAlgebra_mvSize[m_gu & 3] + 0] : 0.0;
  }
  /// Returns the gamma_0_gamma_2 coordinate of this mv.
  inline double get_gamma_0_gamma_2() const {
    return (m_gu & 4) ? m_c[SpacetimeAlgebra_mvSize[m_gu & 3] + 1] : 0.0;
  }
  /// Returns the gamma_1_gamma_2 coordinate of this mv.
  inline double get_gamma_1_gamma_2() const {
    return (m_gu & 4) ? m_c[SpacetimeAlgebra_mvSize[m_gu & 3] + 2] : 0.0;
  }
  /// Returns the gamma_0_gamma_3 coordinate of this mv.
  inline double get_gamma_0_gamma_3() const {
    return (m_gu & 4) ? m_c[SpacetimeAlgebra_mvSize[m_gu & 3] + 3] : 0.0;
  }
  /// Returns the gamma_1_gamma_3 coordinate of this mv.
  inline double get_gamma_1_gamma_3() const {
    return (m_gu & 4) ? m_c[SpacetimeAlgebra_mvSize[m_gu & 3] + 4] : 0.0;
  }
  /// Returns the gamma_2_gamma_3 coordinate of this mv.
  inline double get_gamma_2_gamma_3() const {
    return (m_gu & 4) ? m_c[SpacetimeAlgebra_mvSize[m_gu & 3] + 5] : 0.0;
  }
  /// Returns the gamma_0_gamma_1_gamma_2 coordinate of this mv.
  inline double get_gamma_0_gamma_1_gamma_2() const {
    return (m_gu & 8) ? m_c[SpacetimeAlgebra_mvSize[m_gu & 7] + 0] : 0.0;
  }
  /// Returns the gamma_0_gamma_1_gamma_3 coordinate of this mv.
  inline double get_gamma_0_gamma_1_gamma_3() const {
    return (m_gu & 8) ? m_c[SpacetimeAlgebra_mvSize[m_gu & 7] + 1] : 0.0;
  }
  /// Returns the gamma_0_gamma_2_gamma_3 coordinate of this mv.
  inline double get_gamma_0_gamma_2_gamma_3() const {
    return (m_gu & 8) ? m_c[SpacetimeAlgebra_mvSize[m_gu & 7] + 2] : 0.0;
  }
  /// Returns the gamma_1_gamma_2_gamma_3 coordinate of this mv.
  inline double get_gamma_1_gamma_2_gamma_3() const {
    return (m_gu & 8) ? m_c[SpacetimeAlgebra_mvSize[m_gu & 7] + 3] : 0.0;
  }
  /// Returns the gamma_0_gamma_1_gamma_2_gamma_3 coordinate of this mv.
  inline double get_gamma_0_gamma_1_gamma_2_gamma_3() const {
    return (m_gu & 16) ? m_c[SpacetimeAlgebra_mvSize[m_gu & 15] + 0] : 0.0;
  }
  /// Returns array of compressed coordinates.
  inline const double *getC() const { return m_c;}
  /// Sets the scalar coordinate of this mv.
  inline void set_scalar(double val)  {
    reserveGroup_0();
    m_c[SpacetimeAlgebra_mvSize[m_gu & 0] + 0] = val;
  }
  /// Sets the gamma_0 coordinate of this mv.
  inline void set_gamma_0(double val)  {
    reserveGroup_1();
    m_c[SpacetimeAlgebra_mvSize[m_gu & 1] + 0] = val;
  }
  /// Sets the gamma_1 coordinate of this mv.
  inline void set_gamma_1(double val)  {
    reserveGroup_1();
    m_c[SpacetimeAlgebra_mvSize[m_gu & 1] + 1] = val;
  }
  /// Sets the gamma_2 coordinate of this mv.
  inline void set_gamma_2(double val)  {
    reserveGroup_1();
    m_c[SpacetimeAlgebra_mvSize[m_gu & 1] + 2] = val;
  }
  /// Sets the gamma_3 coordinate of this mv.
  inline void set_gamma_3(double val)  {
    reserveGroup_1();
    m_c[SpacetimeAlgebra_mvSize[m_gu & 1] + 3] = val;
  }
  /// Sets the gamma_0_gamma_1 coordinate of this mv.
  inline void set_gamma_0_gamma_1(double val)  {
    reserveGroup_2();
    m_c[SpacetimeAlgebra_mvSize[m_gu & 3] + 0] = val;
  }
  /// Sets the gamma_0_gamma_2 coordinate of this mv.
  inline void set_gamma_0_gamma_2(double val)  {
    reserveGroup_2();
    m_c[SpacetimeAlgebra_mvSize[m_gu & 3] + 1] = val;
  }
  /// Sets the gamma_1_gamma_2 coordinate of this mv.
  inline void set_gamma_1_gamma_2(double val)  {
    reserveGroup_2();
    m_c[SpacetimeAlgebra_mvSize[m_gu & 3] + 2] = val;
  }
  /// Sets the gamma_0_gamma_3 coordinate of this mv.
  inline void set_gamma_0_gamma_3(double val)  {
    reserveGroup_2();
    m_c[SpacetimeAlgebra_mvSize[m_gu & 3] + 3] = val;
  }
  /// Sets the gamma_1_gamma_3 coordinate of this mv.
  inline void set_gamma_1_gamma_3(double val)  {
    reserveGroup_2();
    m_c[SpacetimeAlgebra_mvSize[m_gu & 3] + 4] = val;
  }
  /// Sets the gamma_2_gamma_3 coordinate of this mv.
  inline void set_gamma_2_gamma_3(double val)  {
    reserveGroup_2();
    m_c[SpacetimeAlgebra_mvSize[m_gu & 3] + 5] = val;
  }
  /// Sets the gamma_0_gamma_1_gamma_2 coordinate of this mv.
  inline void set_gamma_0_gamma_1_gamma_2(double val)  {
    reserveGroup_3();
    m_c[SpacetimeAlgebra_mvSize[m_gu & 7] + 0] = val;
  }
  /// Sets the gamma_0_gamma_1_gamma_3 coordinate of this mv.
  inline void set_gamma_0_gamma_1_gamma_3(double val)  {
    reserveGroup_3();
    m_c[SpacetimeAlgebra_mvSize[m_gu & 7] + 1] = val;
  }
  /// Sets the gamma_0_gamma_2_gamma_3 coordinate of this mv.
  inline void set_gamma_0_gamma_2_gamma_3(double val)  {
    reserveGroup_3();
    m_c[SpacetimeAlgebra_mvSize[m_gu & 7] + 2] = val;
  }
  /// Sets the gamma_1_gamma_2_gamma_3 coordinate of this mv.
  inline void set_gamma_1_gamma_2_gamma_3(double val)  {
    reserveGroup_3();
    m_c[SpacetimeAlgebra_mvSize[m_gu & 7] + 3] = val;
  }
  /// Sets the gamma_0_gamma_1_gamma_2_gamma_3 coordinate of this mv.
  inline void set_gamma_0_gamma_1_gamma_2_gamma_3(double val)  {
    reserveGroup_4();
    m_c[SpacetimeAlgebra_mvSize[m_gu & 15] + 0] = val;
  }

  /// Compresses this mv by removing groups/grades with coordinates are smaller than epsilon.
  void compress(double epsilon = 0.0);
  /// Sets each entry in 'ptrs' to a pointer to the coordinates for the respective grade / group.
  /// \param ptrs Array of pointers to grades/groups. The pointers are set by this function.
  /// \param nulls When true, pointers are set to NULL for empty grades/groups; otherwise a pointer to an array filled with zeros is used.
  void expand(const double *ptrs[5], bool nulls = true) const;

  /// returns the absolute largest coordinate.
  double largestCoordinate() const;
  /// returns the absolute largest coordinate, and the corresponding basis blade bitmap (in 'bm').
  double largestBasisBlade(unsigned int &bm) const;
  /// returns grade/group.
  inline int gu() const {return m_gu;}

  /// Returns a string representation (const char*) of this multivector.
  /// Not multi-threading safe.
  /// \param fp how floats are printed (e.g., "%f");
  inline const char * c_str(const char *fp = NULL) const {
    static char buf[2048]; // not MT-safe
    return ::SpacetimeAlgebra::c_str(*this, buf, 2048, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  /// Not multi-threading safe.
  inline const char * c_str_f() const {return c_str("%f");}
  /// Returns a string representation (const char*) of this multivector using %e
  /// Not multi-threading safe.
  inline const char * c_str_e() const {return c_str("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
  /// Not multi-threading safe.
  inline const char * c_str_e20() const {return c_str("%2.20e");}

  /// Returns a string representation (const char*) of this multivector.
  inline std::string toString(const char *fp = NULL) const {
    return ::SpacetimeAlgebra::toString(*this, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  inline std::string toString_f() const {return toString("%f");}
  /// Returns a string representation (const char*) of this multivector using %e.
  inline std::string toString_e() const {return toString("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20.
  inline std::string toString_e20() const {return toString("%2.20e");}
public:
  inline double const *nullFloats() const {
    static double *nf = NULL;
    return (nf == NULL) ? (nf = new double[16]) : nf;
  }

public:
  /// Set m_gu, reallocates m_c to the size required by gu
  inline void setGroupUsage(int gu) {
    if (m_gu == gu) return;
    m_gu = gu;
  }

  /**
  Allocates memory for coordinate GROUP_0.
  If the group is already present, nothing changes.
  If the group is not present, memory is allocated for the new group,
  and the coordinates for the group are set to zero.
  */
  inline void reserveGroup_0() {
    if ((m_gu & 1) == 0) {
      const int groupUsageBelow = m_gu & 0;
      const int groupUsageAbove = m_gu ^ groupUsageBelow;
      const int newGroupUsage = m_gu | 1;
      const int newGroupUsageBelowNextGroup = newGroupUsage & 1;

      setGroupUsage(newGroupUsage);

      // move coordinate beyond new group
      double *dst = m_c + SpacetimeAlgebra_mvSize[newGroupUsageBelowNextGroup];
      double *src = m_c + SpacetimeAlgebra_mvSize[groupUsageBelow];
      for (int i = SpacetimeAlgebra_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
        dst[i] = src[i];

      // set coordinates of new group to 0
      double *ptr = m_c + SpacetimeAlgebra_mvSize[groupUsageBelow];
      ptr[0] = 0.0;
    }
  }
  /**
  Allocates memory for coordinate GROUP_1.
  If the group is already present, nothing changes.
  If the group is not present, memory is allocated for the new group,
  and the coordinates for the group are set to zero.
  */
  inline void reserveGroup_1() {
    if ((m_gu & 2) == 0) {
      const int groupUsageBelow = m_gu & 1;
      const int groupUsageAbove = m_gu ^ groupUsageBelow;
      const int newGroupUsage = m_gu | 2;
      const int newGroupUsageBelowNextGroup = newGroupUsage & 3;

      setGroupUsage(newGroupUsage);

      // move coordinate beyond new group
      double *dst = m_c + SpacetimeAlgebra_mvSize[newGroupUsageBelowNextGroup];
      double *src = m_c + SpacetimeAlgebra_mvSize[groupUsageBelow];
      for (int i = SpacetimeAlgebra_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
        dst[i] = src[i];

      // set coordinates of new group to 0
      double *ptr = m_c + SpacetimeAlgebra_mvSize[groupUsageBelow];
      ptr[0] = ptr[1] = ptr[2] = ptr[3] = 0.0;
    }
  }
  /**
  Allocates memory for coordinate GROUP_2.
  If the group is already present, nothing changes.
  If the group is not present, memory is allocated for the new group,
  and the coordinates for the group are set to zero.
  */
  inline void reserveGroup_2() {
    if ((m_gu & 4) == 0) {
      const int groupUsageBelow = m_gu & 3;
      const int groupUsageAbove = m_gu ^ groupUsageBelow;
      const int newGroupUsage = m_gu | 4;
      const int newGroupUsageBelowNextGroup = newGroupUsage & 7;

      setGroupUsage(newGroupUsage);

      // move coordinate beyond new group
      double *dst = m_c + SpacetimeAlgebra_mvSize[newGroupUsageBelowNextGroup];
      double *src = m_c + SpacetimeAlgebra_mvSize[groupUsageBelow];
      for (int i = SpacetimeAlgebra_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
        dst[i] = src[i];

      // set coordinates of new group to 0
      double *ptr = m_c + SpacetimeAlgebra_mvSize[groupUsageBelow];
      ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = ptr[5] = 0.0;
    }
  }
  /**
  Allocates memory for coordinate GROUP_3.
  If the group is already present, nothing changes.
  If the group is not present, memory is allocated for the new group,
  and the coordinates for the group are set to zero.
  */
  inline void reserveGroup_3() {
    if ((m_gu & 8) == 0) {
      const int groupUsageBelow = m_gu & 7;
      const int groupUsageAbove = m_gu ^ groupUsageBelow;
      const int newGroupUsage = m_gu | 8;
      const int newGroupUsageBelowNextGroup = newGroupUsage & 15;

      setGroupUsage(newGroupUsage);

      // move coordinate beyond new group
      double *dst = m_c + SpacetimeAlgebra_mvSize[newGroupUsageBelowNextGroup];
      double *src = m_c + SpacetimeAlgebra_mvSize[groupUsageBelow];
      for (int i = SpacetimeAlgebra_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
        dst[i] = src[i];

      // set coordinates of new group to 0
      double *ptr = m_c + SpacetimeAlgebra_mvSize[groupUsageBelow];
      ptr[0] = ptr[1] = ptr[2] = ptr[3] = 0.0;
    }
  }
  /**
  Allocates memory for coordinate GROUP_4.
  If the group is already present, nothing changes.
  If the group is not present, memory is allocated for the new group,
  and the coordinates for the group are set to zero.
  */
  inline void reserveGroup_4() {
    if ((m_gu & 16) == 0) {
      const int groupUsageBelow = m_gu & 15;
      const int groupUsageAbove = m_gu ^ groupUsageBelow;
      const int newGroupUsage = m_gu | 16;
      const int newGroupUsageBelowNextGroup = newGroupUsage & 31;

      setGroupUsage(newGroupUsage);


      // set coordinates of new group to 0
      double *ptr = m_c + SpacetimeAlgebra_mvSize[groupUsageBelow];
      ptr[0] = 0.0;
    }
  }
}; // end of class mv

/// This class can hold a specialized multivector of type gamma_0_t.
///
/// The coordinates are stored in type double.
///
/// The type is constant.
///
/// The constant non-zero coordinates are:
///   - gamma_0 = 1
///
///
class gamma_0_t
{
public:
public:

  /// Floating point type used by gamma_0_t
  typedef double Float;
  /// Array indices of gamma_0_t coordinates.
  typedef enum {
  } ArrayIndex;
  typedef enum {
    /// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
    coord
  } CoordinateOrder;

  /// Constructs a new gamma_0_t with variable coordinates set to 0.
  inline gamma_0_t() {set();}

  /// Copy constructor.
  inline gamma_0_t(const gamma_0_t &A) {set(A);}



  /// Constructs a new gamma_0_t from mv.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  /// \param filler This argument can have any value; it's role
  /// is only to prevent the compiler from using this constructor as a converter.
  inline gamma_0_t(mv &A, int filler) {set(A);}


  /// Assignment operator (gamma_0_t).
  inline gamma_0_t &operator=(const gamma_0_t &A) {if (this != &A) {set(A);} return *this;}



  /// Assignment operator (mv).
  inline gamma_0_t &operator=(const mv &A) {set(A); return *this;}


  /// Sets variable coordinates of 'this' to 0.
  inline void set() {}
  /// Sets this to 'A'.
  void set(const gamma_0_t &A);


  /// Sets this to 'A'.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  void set(const mv &A);



  /// returns the absolute largest coordinate.
  double largestCoordinate() const;
  /// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
  double largestBasisBlade(unsigned int &bm) const;


  /// Returns a string representation (const char*) of this multivector.
  /// Not multi-threading safe.
  /// \param fp how floats are printed (e.g., "%f");
  inline const char * c_str(const char *fp = NULL) const {
    static char buf[2048]; // not MT-safe
    return ::SpacetimeAlgebra::c_str(*this, buf, 2048, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  /// Not multi-threading safe.
  inline const char * c_str_f() const {return c_str("%f");}
  /// Returns a string representation (const char*) of this multivector using %e
  /// Not multi-threading safe.
  inline const char * c_str_e() const {return c_str("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
  /// Not multi-threading safe.
  inline const char * c_str_e20() const {return c_str("%2.20e");}

  /// Returns a string representation (const char*) of this multivector.
  inline std::string toString(const char *fp = NULL) const {
    return ::SpacetimeAlgebra::toString(*this, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  inline std::string toString_f() const {return toString("%f");}
  /// Returns a string representation (const char*) of this multivector using %e.
  inline std::string toString_e() const {return toString("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20.
  inline std::string toString_e20() const {return toString("%2.20e");}

  /// Returns the gamma_0 coordinate.
  inline double get_gamma_0() const { return 1.0;}
  /// Returns the scalar coordinate (which is always 0).
  inline double get_scalar() const { return 0.0;}
}; // end of class gamma_0_t

/// This class can hold a specialized multivector of type gamma_1_t.
///
/// The coordinates are stored in type double.
///
/// The type is constant.
///
/// The constant non-zero coordinates are:
///   - gamma_1 = 1
///
///
class gamma_1_t
{
public:
public:

  /// Floating point type used by gamma_1_t
  typedef double Float;
  /// Array indices of gamma_1_t coordinates.
  typedef enum {
  } ArrayIndex;
  typedef enum {
    /// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
    coord
  } CoordinateOrder;

  /// Constructs a new gamma_1_t with variable coordinates set to 0.
  inline gamma_1_t() {set();}

  /// Copy constructor.
  inline gamma_1_t(const gamma_1_t &A) {set(A);}



  /// Constructs a new gamma_1_t from mv.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  /// \param filler This argument can have any value; it's role
  /// is only to prevent the compiler from using this constructor as a converter.
  inline gamma_1_t(mv &A, int filler) {set(A);}


  /// Assignment operator (gamma_1_t).
  inline gamma_1_t &operator=(const gamma_1_t &A) {if (this != &A) {set(A);} return *this;}



  /// Assignment operator (mv).
  inline gamma_1_t &operator=(const mv &A) {set(A); return *this;}


  /// Sets variable coordinates of 'this' to 0.
  inline void set() {}
  /// Sets this to 'A'.
  void set(const gamma_1_t &A);


  /// Sets this to 'A'.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  void set(const mv &A);



  /// returns the absolute largest coordinate.
  double largestCoordinate() const;
  /// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
  double largestBasisBlade(unsigned int &bm) const;


  /// Returns a string representation (const char*) of this multivector.
  /// Not multi-threading safe.
  /// \param fp how floats are printed (e.g., "%f");
  inline const char * c_str(const char *fp = NULL) const {
    static char buf[2048]; // not MT-safe
    return ::SpacetimeAlgebra::c_str(*this, buf, 2048, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  /// Not multi-threading safe.
  inline const char * c_str_f() const {return c_str("%f");}
  /// Returns a string representation (const char*) of this multivector using %e
  /// Not multi-threading safe.
  inline const char * c_str_e() const {return c_str("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
  /// Not multi-threading safe.
  inline const char * c_str_e20() const {return c_str("%2.20e");}

  /// Returns a string representation (const char*) of this multivector.
  inline std::string toString(const char *fp = NULL) const {
    return ::SpacetimeAlgebra::toString(*this, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  inline std::string toString_f() const {return toString("%f");}
  /// Returns a string representation (const char*) of this multivector using %e.
  inline std::string toString_e() const {return toString("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20.
  inline std::string toString_e20() const {return toString("%2.20e");}

  /// Returns the gamma_1 coordinate.
  inline double get_gamma_1() const { return 1.0;}
  /// Returns the scalar coordinate (which is always 0).
  inline double get_scalar() const { return 0.0;}
}; // end of class gamma_1_t

/// This class can hold a specialized multivector of type gamma_2_t.
///
/// The coordinates are stored in type double.
///
/// The type is constant.
///
/// The constant non-zero coordinates are:
///   - gamma_2 = 1
///
///
class gamma_2_t
{
public:
public:

  /// Floating point type used by gamma_2_t
  typedef double Float;
  /// Array indices of gamma_2_t coordinates.
  typedef enum {
  } ArrayIndex;
  typedef enum {
    /// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
    coord
  } CoordinateOrder;

  /// Constructs a new gamma_2_t with variable coordinates set to 0.
  inline gamma_2_t() {set();}

  /// Copy constructor.
  inline gamma_2_t(const gamma_2_t &A) {set(A);}



  /// Constructs a new gamma_2_t from mv.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  /// \param filler This argument can have any value; it's role
  /// is only to prevent the compiler from using this constructor as a converter.
  inline gamma_2_t(mv &A, int filler) {set(A);}


  /// Assignment operator (gamma_2_t).
  inline gamma_2_t &operator=(const gamma_2_t &A) {if (this != &A) {set(A);} return *this;}



  /// Assignment operator (mv).
  inline gamma_2_t &operator=(const mv &A) {set(A); return *this;}


  /// Sets variable coordinates of 'this' to 0.
  inline void set() {}
  /// Sets this to 'A'.
  void set(const gamma_2_t &A);


  /// Sets this to 'A'.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  void set(const mv &A);



  /// returns the absolute largest coordinate.
  double largestCoordinate() const;
  /// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
  double largestBasisBlade(unsigned int &bm) const;


  /// Returns a string representation (const char*) of this multivector.
  /// Not multi-threading safe.
  /// \param fp how floats are printed (e.g., "%f");
  inline const char * c_str(const char *fp = NULL) const {
    static char buf[2048]; // not MT-safe
    return ::SpacetimeAlgebra::c_str(*this, buf, 2048, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  /// Not multi-threading safe.
  inline const char * c_str_f() const {return c_str("%f");}
  /// Returns a string representation (const char*) of this multivector using %e
  /// Not multi-threading safe.
  inline const char * c_str_e() const {return c_str("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
  /// Not multi-threading safe.
  inline const char * c_str_e20() const {return c_str("%2.20e");}

  /// Returns a string representation (const char*) of this multivector.
  inline std::string toString(const char *fp = NULL) const {
    return ::SpacetimeAlgebra::toString(*this, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  inline std::string toString_f() const {return toString("%f");}
  /// Returns a string representation (const char*) of this multivector using %e.
  inline std::string toString_e() const {return toString("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20.
  inline std::string toString_e20() const {return toString("%2.20e");}

  /// Returns the gamma_2 coordinate.
  inline double get_gamma_2() const { return 1.0;}
  /// Returns the scalar coordinate (which is always 0).
  inline double get_scalar() const { return 0.0;}
}; // end of class gamma_2_t

/// This class can hold a specialized multivector of type gamma_3_t.
///
/// The coordinates are stored in type double.
///
/// The type is constant.
///
/// The constant non-zero coordinates are:
///   - gamma_3 = 1
///
///
class gamma_3_t
{
public:
public:

  /// Floating point type used by gamma_3_t
  typedef double Float;
  /// Array indices of gamma_3_t coordinates.
  typedef enum {
  } ArrayIndex;
  typedef enum {
    /// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
    coord
  } CoordinateOrder;

  /// Constructs a new gamma_3_t with variable coordinates set to 0.
  inline gamma_3_t() {set();}

  /// Copy constructor.
  inline gamma_3_t(const gamma_3_t &A) {set(A);}



  /// Constructs a new gamma_3_t from mv.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  /// \param filler This argument can have any value; it's role
  /// is only to prevent the compiler from using this constructor as a converter.
  inline gamma_3_t(mv &A, int filler) {set(A);}


  /// Assignment operator (gamma_3_t).
  inline gamma_3_t &operator=(const gamma_3_t &A) {if (this != &A) {set(A);} return *this;}



  /// Assignment operator (mv).
  inline gamma_3_t &operator=(const mv &A) {set(A); return *this;}


  /// Sets variable coordinates of 'this' to 0.
  inline void set() {}
  /// Sets this to 'A'.
  void set(const gamma_3_t &A);


  /// Sets this to 'A'.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  void set(const mv &A);



  /// returns the absolute largest coordinate.
  double largestCoordinate() const;
  /// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
  double largestBasisBlade(unsigned int &bm) const;


  /// Returns a string representation (const char*) of this multivector.
  /// Not multi-threading safe.
  /// \param fp how floats are printed (e.g., "%f");
  inline const char * c_str(const char *fp = NULL) const {
    static char buf[2048]; // not MT-safe
    return ::SpacetimeAlgebra::c_str(*this, buf, 2048, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  /// Not multi-threading safe.
  inline const char * c_str_f() const {return c_str("%f");}
  /// Returns a string representation (const char*) of this multivector using %e
  /// Not multi-threading safe.
  inline const char * c_str_e() const {return c_str("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
  /// Not multi-threading safe.
  inline const char * c_str_e20() const {return c_str("%2.20e");}

  /// Returns a string representation (const char*) of this multivector.
  inline std::string toString(const char *fp = NULL) const {
    return ::SpacetimeAlgebra::toString(*this, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  inline std::string toString_f() const {return toString("%f");}
  /// Returns a string representation (const char*) of this multivector using %e.
  inline std::string toString_e() const {return toString("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20.
  inline std::string toString_e20() const {return toString("%2.20e");}

  /// Returns the gamma_3 coordinate.
  inline double get_gamma_3() const { return 1.0;}
  /// Returns the scalar coordinate (which is always 0).
  inline double get_scalar() const { return 0.0;}
}; // end of class gamma_3_t

/// This class can hold a specialized multivector of type I_t.
///
/// The coordinates are stored in type double.
///
/// The type is constant.
///
/// The constant non-zero coordinates are:
///   - gamma_0^gamma_1^gamma_2^gamma_3 = 1
///
///
class I_t
{
public:
public:

  /// Floating point type used by I_t
  typedef double Float;
  /// Array indices of I_t coordinates.
  typedef enum {
  } ArrayIndex;
  typedef enum {
    /// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
    coord
  } CoordinateOrder;

  /// Constructs a new I_t with variable coordinates set to 0.
  inline I_t() {set();}

  /// Copy constructor.
  inline I_t(const I_t &A) {set(A);}



  /// Constructs a new I_t from mv.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  /// \param filler This argument can have any value; it's role
  /// is only to prevent the compiler from using this constructor as a converter.
  inline I_t(mv &A, int filler) {set(A);}


  /// Assignment operator (I_t).
  inline I_t &operator=(const I_t &A) {if (this != &A) {set(A);} return *this;}



  /// Assignment operator (mv).
  inline I_t &operator=(const mv &A) {set(A); return *this;}


  /// Sets variable coordinates of 'this' to 0.
  inline void set() {}
  /// Sets this to 'A'.
  void set(const I_t &A);


  /// Sets this to 'A'.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  void set(const mv &A);



  /// returns the absolute largest coordinate.
  double largestCoordinate() const;
  /// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
  double largestBasisBlade(unsigned int &bm) const;


  /// Returns a string representation (const char*) of this multivector.
  /// Not multi-threading safe.
  /// \param fp how floats are printed (e.g., "%f");
  inline const char * c_str(const char *fp = NULL) const {
    static char buf[2048]; // not MT-safe
    return ::SpacetimeAlgebra::c_str(*this, buf, 2048, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  /// Not multi-threading safe.
  inline const char * c_str_f() const {return c_str("%f");}
  /// Returns a string representation (const char*) of this multivector using %e
  /// Not multi-threading safe.
  inline const char * c_str_e() const {return c_str("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
  /// Not multi-threading safe.
  inline const char * c_str_e20() const {return c_str("%2.20e");}

  /// Returns a string representation (const char*) of this multivector.
  inline std::string toString(const char *fp = NULL) const {
    return ::SpacetimeAlgebra::toString(*this, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  inline std::string toString_f() const {return toString("%f");}
  /// Returns a string representation (const char*) of this multivector using %e.
  inline std::string toString_e() const {return toString("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20.
  inline std::string toString_e20() const {return toString("%2.20e");}

  /// Returns the gamma_0^gamma_1^gamma_2^gamma_3 coordinate.
  inline double get_gamma_0_gamma_1_gamma_2_gamma_3() const { return 1.0;}
  /// Returns the scalar coordinate (which is always 0).
  inline double get_scalar() const { return 0.0;}
}; // end of class I_t

/// This class can hold a specialized multivector of type I3_t.
///
/// The coordinates are stored in type double.
///
/// The type is constant.
///
/// The constant non-zero coordinates are:
///   - gamma_1^gamma_2^gamma_3 = 1
///
///
class I3_t
{
public:
public:

  /// Floating point type used by I3_t
  typedef double Float;
  /// Array indices of I3_t coordinates.
  typedef enum {
  } ArrayIndex;
  typedef enum {
    /// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
    coord
  } CoordinateOrder;

  /// Constructs a new I3_t with variable coordinates set to 0.
  inline I3_t() {set();}

  /// Copy constructor.
  inline I3_t(const I3_t &A) {set(A);}



  /// Constructs a new I3_t from mv.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  /// \param filler This argument can have any value; it's role
  /// is only to prevent the compiler from using this constructor as a converter.
  inline I3_t(mv &A, int filler) {set(A);}


  /// Assignment operator (I3_t).
  inline I3_t &operator=(const I3_t &A) {if (this != &A) {set(A);} return *this;}



  /// Assignment operator (mv).
  inline I3_t &operator=(const mv &A) {set(A); return *this;}


  /// Sets variable coordinates of 'this' to 0.
  inline void set() {}
  /// Sets this to 'A'.
  void set(const I3_t &A);


  /// Sets this to 'A'.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  void set(const mv &A);



  /// returns the absolute largest coordinate.
  double largestCoordinate() const;
  /// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
  double largestBasisBlade(unsigned int &bm) const;


  /// Returns a string representation (const char*) of this multivector.
  /// Not multi-threading safe.
  /// \param fp how floats are printed (e.g., "%f");
  inline const char * c_str(const char *fp = NULL) const {
    static char buf[2048]; // not MT-safe
    return ::SpacetimeAlgebra::c_str(*this, buf, 2048, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  /// Not multi-threading safe.
  inline const char * c_str_f() const {return c_str("%f");}
  /// Returns a string representation (const char*) of this multivector using %e
  /// Not multi-threading safe.
  inline const char * c_str_e() const {return c_str("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
  /// Not multi-threading safe.
  inline const char * c_str_e20() const {return c_str("%2.20e");}

  /// Returns a string representation (const char*) of this multivector.
  inline std::string toString(const char *fp = NULL) const {
    return ::SpacetimeAlgebra::toString(*this, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  inline std::string toString_f() const {return toString("%f");}
  /// Returns a string representation (const char*) of this multivector using %e.
  inline std::string toString_e() const {return toString("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20.
  inline std::string toString_e20() const {return toString("%2.20e");}

  /// Returns the gamma_1^gamma_2^gamma_3 coordinate.
  inline double get_gamma_1_gamma_2_gamma_3() const { return 1.0;}
  /// Returns the scalar coordinate (which is always 0).
  inline double get_scalar() const { return 0.0;}
}; // end of class I3_t

/// This class can hold a specialized multivector of type mv3.
///
/// The coordinates are stored in type double.
///
/// The variable non-zero coordinates are:
///   - coordinate 1  (array index: SCALAR = 0)
///   - coordinate gamma_1  (array index: GAMMA_1 = 1)
///   - coordinate gamma_2  (array index: GAMMA_2 = 2)
///   - coordinate gamma_3  (array index: GAMMA_3 = 3)
///   - coordinate gamma_1^gamma_2  (array index: GAMMA_1_GAMMA_2 = 4)
///   - coordinate gamma_1^gamma_3  (array index: GAMMA_1_GAMMA_3 = 5)
///   - coordinate gamma_2^gamma_3  (array index: GAMMA_2_GAMMA_3 = 6)
///   - coordinate gamma_1^gamma_2^gamma_3  (array index: GAMMA_1_GAMMA_2_GAMMA_3 = 7)
///
/// The type has no constant coordinates.
///
///
class mv3
{
public:
  /// The coordinates (stored in an array).
  double m_c[8]; // 1, gamma_1, gamma_2, gamma_3, gamma_1^gamma_2, gamma_1^gamma_3, gamma_2^gamma_3, gamma_1^gamma_2^gamma_3
public:

  /// Floating point type used by mv3
  typedef double Float;
  /// Array indices of mv3 coordinates.
  typedef enum {
    /// index of coordinate for 1 in mv3
    SCALAR = 0,
    /// index of coordinate for gamma_1 in mv3
    GAMMA_1 = 1,
    /// index of coordinate for gamma_2 in mv3
    GAMMA_2 = 2,
    /// index of coordinate for gamma_3 in mv3
    GAMMA_3 = 3,
    /// index of coordinate for gamma_1^gamma_2 in mv3
    GAMMA_1_GAMMA_2 = 4,
    /// index of coordinate for gamma_1^gamma_3 in mv3
    GAMMA_1_GAMMA_3 = 5,
    /// index of coordinate for gamma_2^gamma_3 in mv3
    GAMMA_2_GAMMA_3 = 6,
    /// index of coordinate for gamma_1^gamma_2^gamma_3 in mv3
    GAMMA_1_GAMMA_2_GAMMA_3 = 7,
  } ArrayIndex;
  typedef enum {
    /// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
    coord_scalar_gamma_1_gamma_2_gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_1gamma_2gamma_3
  } CoordinateOrder;

  /// Constructs a new mv3 with variable coordinates set to 0.
  inline mv3() {set();}

  /// Copy constructor.
  inline mv3(const mv3 &A) {set(A);}


  /// Constructs a new mv3 with scalar value 'scalar'.
  inline mv3(double scalar) {set(scalar);}

  /// Constructs a new mv3 from mv.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  /// \param filler This argument can have any value; it's role
  /// is only to prevent the compiler from using this constructor as a converter.
  inline mv3(mv &A, int filler) {set(A);}

  /// Constructs a new mv3. Coordinate values come from 'A'.
  inline mv3(const CoordinateOrder co, const double A[8]) {set(co, A);}

  /// Constructs a new mv3 with each coordinate specified.
  inline mv3(const CoordinateOrder co,  double scalar, double gamma_1, double gamma_2, double gamma_3, double gamma_1_gamma_2, double gamma_1_gamma_3, double gamma_2_gamma_3, double gamma_1_gamma_2_gamma_3) {
    set(co, scalar, gamma_1, gamma_2, gamma_3, gamma_1_gamma_2, gamma_1_gamma_3, gamma_2_gamma_3, gamma_1_gamma_2_gamma_3);
  }

  /// Assignment operator (mv3).
  inline mv3 &operator=(const mv3 &A) {if (this != &A) {set(A);} return *this;}


  /// Assignment operator (double).
  inline mv3 &operator=(const double &scalar) {set(scalar); return *this;}

  /// Assignment operator (mv).
  inline mv3 &operator=(const mv &A) {set(A); return *this;}


  /// Sets variable coordinates of 'this' to 0.
  void set();
  /// Sets this to 'A'.
  void set(const mv3 &A);

  /// Sets this to scalar value 'scalar'.
  void set(double scalar);

  /// Sets this to 'A'.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  void set(const mv &A);


  /// Sets this to 'A'.
  void set(const CoordinateOrder, const double A[8]);

  /// Sets this to coordinates specified.
  void set(const CoordinateOrder,  double scalar, double gamma_1, double gamma_2, double gamma_3, double gamma_1_gamma_2, double gamma_1_gamma_3, double gamma_2_gamma_3, double gamma_1_gamma_2_gamma_3);

  /// returns the absolute largest coordinate.
  double largestCoordinate() const;
  /// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
  double largestBasisBlade(unsigned int &bm) const;


  /// Returns a string representation (const char*) of this multivector.
  /// Not multi-threading safe.
  /// \param fp how floats are printed (e.g., "%f");
  inline const char * c_str(const char *fp = NULL) const {
    static char buf[2048]; // not MT-safe
    return ::SpacetimeAlgebra::c_str(*this, buf, 2048, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  /// Not multi-threading safe.
  inline const char * c_str_f() const {return c_str("%f");}
  /// Returns a string representation (const char*) of this multivector using %e
  /// Not multi-threading safe.
  inline const char * c_str_e() const {return c_str("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
  /// Not multi-threading safe.
  inline const char * c_str_e20() const {return c_str("%2.20e");}

  /// Returns a string representation (const char*) of this multivector.
  inline std::string toString(const char *fp = NULL) const {
    return ::SpacetimeAlgebra::toString(*this, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  inline std::string toString_f() const {return toString("%f");}
  /// Returns a string representation (const char*) of this multivector using %e.
  inline std::string toString_e() const {return toString("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20.
  inline std::string toString_e20() const {return toString("%2.20e");}

  /// Returns the 1 coordinate.
  inline double get_scalar() const { return m_c[0];}
  /// Sets the 1 coordinate.
  inline void set_scalar(double scalar) { m_c[0] = scalar;}
  /// Returns the gamma_1 coordinate.
  inline double get_gamma_1() const { return m_c[1];}
  /// Sets the gamma_1 coordinate.
  inline void set_gamma_1(double gamma_1) { m_c[1] = gamma_1;}
  /// Returns the gamma_2 coordinate.
  inline double get_gamma_2() const { return m_c[2];}
  /// Sets the gamma_2 coordinate.
  inline void set_gamma_2(double gamma_2) { m_c[2] = gamma_2;}
  /// Returns the gamma_3 coordinate.
  inline double get_gamma_3() const { return m_c[3];}
  /// Sets the gamma_3 coordinate.
  inline void set_gamma_3(double gamma_3) { m_c[3] = gamma_3;}
  /// Returns the gamma_1^gamma_2 coordinate.
  inline double get_gamma_1_gamma_2() const { return m_c[4];}
  /// Sets the gamma_1^gamma_2 coordinate.
  inline void set_gamma_1_gamma_2(double gamma_1_gamma_2) { m_c[4] = gamma_1_gamma_2;}
  /// Returns the gamma_1^gamma_3 coordinate.
  inline double get_gamma_1_gamma_3() const { return m_c[5];}
  /// Sets the gamma_1^gamma_3 coordinate.
  inline void set_gamma_1_gamma_3(double gamma_1_gamma_3) { m_c[5] = gamma_1_gamma_3;}
  /// Returns the gamma_2^gamma_3 coordinate.
  inline double get_gamma_2_gamma_3() const { return m_c[6];}
  /// Sets the gamma_2^gamma_3 coordinate.
  inline void set_gamma_2_gamma_3(double gamma_2_gamma_3) { m_c[6] = gamma_2_gamma_3;}
  /// Returns the gamma_1^gamma_2^gamma_3 coordinate.
  inline double get_gamma_1_gamma_2_gamma_3() const { return m_c[7];}
  /// Sets the gamma_1^gamma_2^gamma_3 coordinate.
  inline void set_gamma_1_gamma_2_gamma_3(double gamma_1_gamma_2_gamma_3) { m_c[7] = gamma_1_gamma_2_gamma_3;}
  /// Returns array of coordinates.
  inline const double *getC(CoordinateOrder) const { return m_c;}
}; // end of class mv3

/// This class can hold a specialized multivector of type vector.
///
/// The coordinates are stored in type double.
///
/// The variable non-zero coordinates are:
///   - coordinate gamma_0  (array index: GAMMA_0 = 0)
///   - coordinate gamma_1  (array index: GAMMA_1 = 1)
///   - coordinate gamma_2  (array index: GAMMA_2 = 2)
///   - coordinate gamma_3  (array index: GAMMA_3 = 3)
///
/// The type has no constant coordinates.
///
///
class vector
{
public:
  /// The coordinates (stored in an array).
  double m_c[4]; // gamma_0, gamma_1, gamma_2, gamma_3
public:

  /// Floating point type used by vector
  typedef double Float;
  /// Array indices of vector coordinates.
  typedef enum {
    /// index of coordinate for gamma_0 in vector
    GAMMA_0 = 0,
    /// index of coordinate for gamma_1 in vector
    GAMMA_1 = 1,
    /// index of coordinate for gamma_2 in vector
    GAMMA_2 = 2,
    /// index of coordinate for gamma_3 in vector
    GAMMA_3 = 3,
  } ArrayIndex;
  typedef enum {
    /// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
    coord_gamma_0_gamma_1_gamma_2_gamma_3
  } CoordinateOrder;

  /// Constructs a new vector with variable coordinates set to 0.
  inline vector() {set();}

  /// Copy constructor.
  inline vector(const vector &A) {set(A);}



  /// Constructs a new vector from mv.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  /// \param filler This argument can have any value; it's role
  /// is only to prevent the compiler from using this constructor as a converter.
  inline vector(const mv &A, int filler) {set(A);}

  /// Constructs a new vector. Coordinate values come from 'A'.
  inline vector(const CoordinateOrder co, const double A[4]) {set(co, A);}

  /// Constructs a new vector with each coordinate specified.
  inline vector(const CoordinateOrder co,  double gamma_0, double gamma_1, double gamma_2, double gamma_3) {
    set(co, gamma_0, gamma_1, gamma_2, gamma_3);
  }

  /// Assignment operator (vector).
  inline vector &operator=(const vector &A) {if (this != &A) {set(A);} return *this;}



  /// Assignment operator (mv).
  inline vector &operator=(const mv &A) {set(A); return *this;}


  /// Sets variable coordinates of 'this' to 0.
  void set();
  /// Sets this to 'A'.
  void set(const vector &A);


  /// Sets this to 'A'.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  void set(const mv &A);


  /// Sets this to 'A'.
  void set(const CoordinateOrder, const double A[4]);

  /// Sets this to coordinates specified.
  void set(const CoordinateOrder,  double gamma_0, double gamma_1, double gamma_2, double gamma_3);

  /// returns the absolute largest coordinate.
  double largestCoordinate() const;
  /// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
  double largestBasisBlade(unsigned int &bm) const;


  /// Returns a string representation (const char*) of this multivector.
  /// Not multi-threading safe.
  /// \param fp how floats are printed (e.g., "%f");
  inline const char * c_str(const char *fp = NULL) const {
    static char buf[2048]; // not MT-safe
    return ::SpacetimeAlgebra::c_str(*this, buf, 2048, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  /// Not multi-threading safe.
  inline const char * c_str_f() const {return c_str("%f");}
  /// Returns a string representation (const char*) of this multivector using %e
  /// Not multi-threading safe.
  inline const char * c_str_e() const {return c_str("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
  /// Not multi-threading safe.
  inline const char * c_str_e20() const {return c_str("%2.20e");}

  /// Returns a string representation (const char*) of this multivector.
  inline std::string toString(const char *fp = NULL) const {
    return ::SpacetimeAlgebra::toString(*this, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  inline std::string toString_f() const {return toString("%f");}
  /// Returns a string representation (const char*) of this multivector using %e.
  inline std::string toString_e() const {return toString("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20.
  inline std::string toString_e20() const {return toString("%2.20e");}

  /// Returns the gamma_0 coordinate.
  inline double get_gamma_0() const { return m_c[0];}
  /// Sets the gamma_0 coordinate.
  inline void set_gamma_0(double gamma_0) { m_c[0] = gamma_0;}
  /// Returns the gamma_1 coordinate.
  inline double get_gamma_1() const { return m_c[1];}
  /// Sets the gamma_1 coordinate.
  inline void set_gamma_1(double gamma_1) { m_c[1] = gamma_1;}
  /// Returns the gamma_2 coordinate.
  inline double get_gamma_2() const { return m_c[2];}
  /// Sets the gamma_2 coordinate.
  inline void set_gamma_2(double gamma_2) { m_c[2] = gamma_2;}
  /// Returns the gamma_3 coordinate.
  inline double get_gamma_3() const { return m_c[3];}
  /// Sets the gamma_3 coordinate.
  inline void set_gamma_3(double gamma_3) { m_c[3] = gamma_3;}
  /// Returns the scalar coordinate (which is always 0).
  inline double get_scalar() const { return 0.0;}
  /// Returns array of coordinates.
  inline const double *getC(CoordinateOrder) const { return m_c;}
}; // end of class vector

/// This class can hold a specialized multivector of type vector3.
///
/// The coordinates are stored in type double.
///
/// The variable non-zero coordinates are:
///   - coordinate gamma_1  (array index: GAMMA_1 = 0)
///   - coordinate gamma_2  (array index: GAMMA_2 = 1)
///   - coordinate gamma_3  (array index: GAMMA_3 = 2)
///
/// The type has no constant coordinates.
///
///
class vector3
{
public:
  /// The coordinates (stored in an array).
  double m_c[3]; // gamma_1, gamma_2, gamma_3
public:

  /// Floating point type used by vector3
  typedef double Float;
  /// Array indices of vector3 coordinates.
  typedef enum {
    /// index of coordinate for gamma_1 in vector3
    GAMMA_1 = 0,
    /// index of coordinate for gamma_2 in vector3
    GAMMA_2 = 1,
    /// index of coordinate for gamma_3 in vector3
    GAMMA_3 = 2,
  } ArrayIndex;
  typedef enum {
    /// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
    coord_gamma_1_gamma_2_gamma_3
  } CoordinateOrder;

  /// Constructs a new vector3 with variable coordinates set to 0.
  inline vector3() {set();}

  /// Copy constructor.
  inline vector3(const vector3 &A) {set(A);}



  /// Constructs a new vector3 from mv.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  /// \param filler This argument can have any value; it's role
  /// is only to prevent the compiler from using this constructor as a converter.
  inline vector3(mv &A, int filler) {set(A);}

  /// Constructs a new vector3. Coordinate values come from 'A'.
  inline vector3(const CoordinateOrder co, const double A[3]) {set(co, A);}

  /// Constructs a new vector3 with each coordinate specified.
  inline vector3(const CoordinateOrder co,  double gamma_1, double gamma_2, double gamma_3) {
    set(co, gamma_1, gamma_2, gamma_3);
  }

  /// Assignment operator (vector3).
  inline vector3 &operator=(const vector3 &A) {if (this != &A) {set(A);} return *this;}



  /// Assignment operator (mv).
  inline vector3 &operator=(const mv &A) {set(A); return *this;}


  /// Sets variable coordinates of 'this' to 0.
  void set();
  /// Sets this to 'A'.
  void set(const vector3 &A);


  /// Sets this to 'A'.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  void set(const mv &A);


  /// Sets this to 'A'.
  void set(const CoordinateOrder, const double A[3]);

  /// Sets this to coordinates specified.
  void set(const CoordinateOrder,  double gamma_1, double gamma_2, double gamma_3);

  /// returns the absolute largest coordinate.
  double largestCoordinate() const;
  /// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
  double largestBasisBlade(unsigned int &bm) const;


  /// Returns a string representation (const char*) of this multivector.
  /// Not multi-threading safe.
  /// \param fp how floats are printed (e.g., "%f");
  inline const char * c_str(const char *fp = NULL) const {
    static char buf[2048]; // not MT-safe
    return ::SpacetimeAlgebra::c_str(*this, buf, 2048, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  /// Not multi-threading safe.
  inline const char * c_str_f() const {return c_str("%f");}
  /// Returns a string representation (const char*) of this multivector using %e
  /// Not multi-threading safe.
  inline const char * c_str_e() const {return c_str("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
  /// Not multi-threading safe.
  inline const char * c_str_e20() const {return c_str("%2.20e");}

  /// Returns a string representation (const char*) of this multivector.
  inline std::string toString(const char *fp = NULL) const {
    return ::SpacetimeAlgebra::toString(*this, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  inline std::string toString_f() const {return toString("%f");}
  /// Returns a string representation (const char*) of this multivector using %e.
  inline std::string toString_e() const {return toString("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20.
  inline std::string toString_e20() const {return toString("%2.20e");}

  /// Returns the gamma_1 coordinate.
  inline double get_gamma_1() const { return m_c[0];}
  /// Sets the gamma_1 coordinate.
  inline void set_gamma_1(double gamma_1) { m_c[0] = gamma_1;}
  /// Returns the gamma_2 coordinate.
  inline double get_gamma_2() const { return m_c[1];}
  /// Sets the gamma_2 coordinate.
  inline void set_gamma_2(double gamma_2) { m_c[1] = gamma_2;}
  /// Returns the gamma_3 coordinate.
  inline double get_gamma_3() const { return m_c[2];}
  /// Sets the gamma_3 coordinate.
  inline void set_gamma_3(double gamma_3) { m_c[2] = gamma_3;}
  /// Returns the scalar coordinate (which is always 0).
  inline double get_scalar() const { return 0.0;}
  /// Returns array of coordinates.
  inline const double *getC(CoordinateOrder) const { return m_c;}
}; // end of class vector3

/// This class can hold a specialized multivector of type bivector.
///
/// The coordinates are stored in type double.
///
/// The variable non-zero coordinates are:
///   - coordinate gamma_0^gamma_1  (array index: GAMMA_0_GAMMA_1 = 0)
///   - coordinate gamma_0^gamma_2  (array index: GAMMA_0_GAMMA_2 = 1)
///   - coordinate gamma_0^gamma_3  (array index: GAMMA_0_GAMMA_3 = 2)
///   - coordinate gamma_1^gamma_2  (array index: GAMMA_1_GAMMA_2 = 3)
///   - coordinate gamma_1^gamma_3  (array index: GAMMA_1_GAMMA_3 = 4)
///   - coordinate gamma_2^gamma_3  (array index: GAMMA_2_GAMMA_3 = 5)
///
/// The type has no constant coordinates.
///
///
class bivector
{
public:
  /// The coordinates (stored in an array).
  double m_c[6]; // gamma_0^gamma_1, gamma_0^gamma_2, gamma_0^gamma_3, gamma_1^gamma_2, gamma_1^gamma_3, gamma_2^gamma_3
public:

  /// Floating point type used by bivector
  typedef double Float;
  /// Array indices of bivector coordinates.
  typedef enum {
    /// index of coordinate for gamma_0^gamma_1 in bivector
    GAMMA_0_GAMMA_1 = 0,
    /// index of coordinate for gamma_0^gamma_2 in bivector
    GAMMA_0_GAMMA_2 = 1,
    /// index of coordinate for gamma_0^gamma_3 in bivector
    GAMMA_0_GAMMA_3 = 2,
    /// index of coordinate for gamma_1^gamma_2 in bivector
    GAMMA_1_GAMMA_2 = 3,
    /// index of coordinate for gamma_1^gamma_3 in bivector
    GAMMA_1_GAMMA_3 = 4,
    /// index of coordinate for gamma_2^gamma_3 in bivector
    GAMMA_2_GAMMA_3 = 5,
  } ArrayIndex;
  typedef enum {
    /// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
    coord_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3
  } CoordinateOrder;

  /// Constructs a new bivector with variable coordinates set to 0.
  inline bivector() {set();}

  /// Copy constructor.
  inline bivector(const bivector &A) {set(A);}



  /// Constructs a new bivector from mv.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  /// \param filler This argument can have any value; it's role
  /// is only to prevent the compiler from using this constructor as a converter.
  inline bivector(mv &A, int filler) {set(A);}

  /// Constructs a new bivector. Coordinate values come from 'A'.
  inline bivector(const CoordinateOrder co, const double A[6]) {set(co, A);}

  /// Constructs a new bivector with each coordinate specified.
  inline bivector(const CoordinateOrder co,  double gamma_0_gamma_1, double gamma_0_gamma_2, double gamma_0_gamma_3, double gamma_1_gamma_2, double gamma_1_gamma_3, double gamma_2_gamma_3) {
    set(co, gamma_0_gamma_1, gamma_0_gamma_2, gamma_0_gamma_3, gamma_1_gamma_2, gamma_1_gamma_3, gamma_2_gamma_3);
  }

  /// Assignment operator (bivector).
  inline bivector &operator=(const bivector &A) {if (this != &A) {set(A);} return *this;}



  /// Assignment operator (mv).
  inline bivector &operator=(const mv &A) {set(A); return *this;}


  /// Sets variable coordinates of 'this' to 0.
  void set();
  /// Sets this to 'A'.
  void set(const bivector &A);


  /// Sets this to 'A'.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  void set(const mv &A);


  /// Sets this to 'A'.
  void set(const CoordinateOrder, const double A[6]);

  /// Sets this to coordinates specified.
  void set(const CoordinateOrder,  double gamma_0_gamma_1, double gamma_0_gamma_2, double gamma_0_gamma_3, double gamma_1_gamma_2, double gamma_1_gamma_3, double gamma_2_gamma_3);

  /// returns the absolute largest coordinate.
  double largestCoordinate() const;
  /// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
  double largestBasisBlade(unsigned int &bm) const;


  /// Returns a string representation (const char*) of this multivector.
  /// Not multi-threading safe.
  /// \param fp how floats are printed (e.g., "%f");
  inline const char * c_str(const char *fp = NULL) const {
    static char buf[2048]; // not MT-safe
    return ::SpacetimeAlgebra::c_str(*this, buf, 2048, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  /// Not multi-threading safe.
  inline const char * c_str_f() const {return c_str("%f");}
  /// Returns a string representation (const char*) of this multivector using %e
  /// Not multi-threading safe.
  inline const char * c_str_e() const {return c_str("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
  /// Not multi-threading safe.
  inline const char * c_str_e20() const {return c_str("%2.20e");}

  /// Returns a string representation (const char*) of this multivector.
  inline std::string toString(const char *fp = NULL) const {
    return ::SpacetimeAlgebra::toString(*this, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  inline std::string toString_f() const {return toString("%f");}
  /// Returns a string representation (const char*) of this multivector using %e.
  inline std::string toString_e() const {return toString("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20.
  inline std::string toString_e20() const {return toString("%2.20e");}

  /// Returns the gamma_0^gamma_1 coordinate.
  inline double get_gamma_0_gamma_1() const { return m_c[0];}
  /// Sets the gamma_0^gamma_1 coordinate.
  inline void set_gamma_0_gamma_1(double gamma_0_gamma_1) { m_c[0] = gamma_0_gamma_1;}
  /// Returns the gamma_0^gamma_2 coordinate.
  inline double get_gamma_0_gamma_2() const { return m_c[1];}
  /// Sets the gamma_0^gamma_2 coordinate.
  inline void set_gamma_0_gamma_2(double gamma_0_gamma_2) { m_c[1] = gamma_0_gamma_2;}
  /// Returns the gamma_0^gamma_3 coordinate.
  inline double get_gamma_0_gamma_3() const { return m_c[2];}
  /// Sets the gamma_0^gamma_3 coordinate.
  inline void set_gamma_0_gamma_3(double gamma_0_gamma_3) { m_c[2] = gamma_0_gamma_3;}
  /// Returns the gamma_1^gamma_2 coordinate.
  inline double get_gamma_1_gamma_2() const { return m_c[3];}
  /// Sets the gamma_1^gamma_2 coordinate.
  inline void set_gamma_1_gamma_2(double gamma_1_gamma_2) { m_c[3] = gamma_1_gamma_2;}
  /// Returns the gamma_1^gamma_3 coordinate.
  inline double get_gamma_1_gamma_3() const { return m_c[4];}
  /// Sets the gamma_1^gamma_3 coordinate.
  inline void set_gamma_1_gamma_3(double gamma_1_gamma_3) { m_c[4] = gamma_1_gamma_3;}
  /// Returns the gamma_2^gamma_3 coordinate.
  inline double get_gamma_2_gamma_3() const { return m_c[5];}
  /// Sets the gamma_2^gamma_3 coordinate.
  inline void set_gamma_2_gamma_3(double gamma_2_gamma_3) { m_c[5] = gamma_2_gamma_3;}
  /// Returns the scalar coordinate (which is always 0).
  inline double get_scalar() const { return 0.0;}
  /// Returns array of coordinates.
  inline const double *getC(CoordinateOrder) const { return m_c;}
}; // end of class bivector

/// This class can hold a specialized multivector of type bivector3.
///
/// The coordinates are stored in type double.
///
/// The variable non-zero coordinates are:
///   - coordinate gamma_1^gamma_2  (array index: GAMMA_1_GAMMA_2 = 0)
///   - coordinate gamma_1^gamma_3  (array index: GAMMA_1_GAMMA_3 = 1)
///   - coordinate gamma_2^gamma_3  (array index: GAMMA_2_GAMMA_3 = 2)
///
/// The type has no constant coordinates.
///
///
class bivector3
{
public:
  /// The coordinates (stored in an array).
  double m_c[3]; // gamma_1^gamma_2, gamma_1^gamma_3, gamma_2^gamma_3
public:

  /// Floating point type used by bivector3
  typedef double Float;
  /// Array indices of bivector3 coordinates.
  typedef enum {
    /// index of coordinate for gamma_1^gamma_2 in bivector3
    GAMMA_1_GAMMA_2 = 0,
    /// index of coordinate for gamma_1^gamma_3 in bivector3
    GAMMA_1_GAMMA_3 = 1,
    /// index of coordinate for gamma_2^gamma_3 in bivector3
    GAMMA_2_GAMMA_3 = 2,
  } ArrayIndex;
  typedef enum {
    /// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
    coord_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3
  } CoordinateOrder;

  /// Constructs a new bivector3 with variable coordinates set to 0.
  inline bivector3() {set();}

  /// Copy constructor.
  inline bivector3(const bivector3 &A) {set(A);}



  /// Constructs a new bivector3 from mv.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  /// \param filler This argument can have any value; it's role
  /// is only to prevent the compiler from using this constructor as a converter.
  inline bivector3(mv &A, int filler) {set(A);}

  /// Constructs a new bivector3. Coordinate values come from 'A'.
  inline bivector3(const CoordinateOrder co, const double A[3]) {set(co, A);}

  /// Constructs a new bivector3 with each coordinate specified.
  inline bivector3(const CoordinateOrder co,  double gamma_1_gamma_2, double gamma_1_gamma_3, double gamma_2_gamma_3) {
    set(co, gamma_1_gamma_2, gamma_1_gamma_3, gamma_2_gamma_3);
  }

  /// Assignment operator (bivector3).
  inline bivector3 &operator=(const bivector3 &A) {if (this != &A) {set(A);} return *this;}



  /// Assignment operator (mv).
  inline bivector3 &operator=(const mv &A) {set(A); return *this;}


  /// Sets variable coordinates of 'this' to 0.
  void set();
  /// Sets this to 'A'.
  void set(const bivector3 &A);


  /// Sets this to 'A'.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  void set(const mv &A);


  /// Sets this to 'A'.
  void set(const CoordinateOrder, const double A[3]);

  /// Sets this to coordinates specified.
  void set(const CoordinateOrder,  double gamma_1_gamma_2, double gamma_1_gamma_3, double gamma_2_gamma_3);

  /// returns the absolute largest coordinate.
  double largestCoordinate() const;
  /// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
  double largestBasisBlade(unsigned int &bm) const;


  /// Returns a string representation (const char*) of this multivector.
  /// Not multi-threading safe.
  /// \param fp how floats are printed (e.g., "%f");
  inline const char * c_str(const char *fp = NULL) const {
    static char buf[2048]; // not MT-safe
    return ::SpacetimeAlgebra::c_str(*this, buf, 2048, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  /// Not multi-threading safe.
  inline const char * c_str_f() const {return c_str("%f");}
  /// Returns a string representation (const char*) of this multivector using %e
  /// Not multi-threading safe.
  inline const char * c_str_e() const {return c_str("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
  /// Not multi-threading safe.
  inline const char * c_str_e20() const {return c_str("%2.20e");}

  /// Returns a string representation (const char*) of this multivector.
  inline std::string toString(const char *fp = NULL) const {
    return ::SpacetimeAlgebra::toString(*this, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  inline std::string toString_f() const {return toString("%f");}
  /// Returns a string representation (const char*) of this multivector using %e.
  inline std::string toString_e() const {return toString("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20.
  inline std::string toString_e20() const {return toString("%2.20e");}

  /// Returns the gamma_1^gamma_2 coordinate.
  inline double get_gamma_1_gamma_2() const { return m_c[0];}
  /// Sets the gamma_1^gamma_2 coordinate.
  inline void set_gamma_1_gamma_2(double gamma_1_gamma_2) { m_c[0] = gamma_1_gamma_2;}
  /// Returns the gamma_1^gamma_3 coordinate.
  inline double get_gamma_1_gamma_3() const { return m_c[1];}
  /// Sets the gamma_1^gamma_3 coordinate.
  inline void set_gamma_1_gamma_3(double gamma_1_gamma_3) { m_c[1] = gamma_1_gamma_3;}
  /// Returns the gamma_2^gamma_3 coordinate.
  inline double get_gamma_2_gamma_3() const { return m_c[2];}
  /// Sets the gamma_2^gamma_3 coordinate.
  inline void set_gamma_2_gamma_3(double gamma_2_gamma_3) { m_c[2] = gamma_2_gamma_3;}
  /// Returns the scalar coordinate (which is always 0).
  inline double get_scalar() const { return 0.0;}
  /// Returns array of coordinates.
  inline const double *getC(CoordinateOrder) const { return m_c;}
}; // end of class bivector3

/// This class can hold a specialized multivector of type pseudovector.
///
/// The coordinates are stored in type double.
///
/// The variable non-zero coordinates are:
///   - coordinate gamma_0^gamma_1^gamma_2  (array index: GAMMA_0_GAMMA_1_GAMMA_2 = 0)
///   - coordinate gamma_0^gamma_1^gamma_3  (array index: GAMMA_0_GAMMA_1_GAMMA_3 = 1)
///   - coordinate gamma_0^gamma_2^gamma_3  (array index: GAMMA_0_GAMMA_2_GAMMA_3 = 2)
///   - coordinate gamma_1^gamma_2^gamma_3  (array index: GAMMA_1_GAMMA_2_GAMMA_3 = 3)
///
/// The type has no constant coordinates.
///
///
class pseudovector
{
public:
  /// The coordinates (stored in an array).
  double m_c[4]; // gamma_0^gamma_1^gamma_2, gamma_0^gamma_1^gamma_3, gamma_0^gamma_2^gamma_3, gamma_1^gamma_2^gamma_3
public:

  /// Floating point type used by pseudovector
  typedef double Float;
  /// Array indices of pseudovector coordinates.
  typedef enum {
    /// index of coordinate for gamma_0^gamma_1^gamma_2 in pseudovector
    GAMMA_0_GAMMA_1_GAMMA_2 = 0,
    /// index of coordinate for gamma_0^gamma_1^gamma_3 in pseudovector
    GAMMA_0_GAMMA_1_GAMMA_3 = 1,
    /// index of coordinate for gamma_0^gamma_2^gamma_3 in pseudovector
    GAMMA_0_GAMMA_2_GAMMA_3 = 2,
    /// index of coordinate for gamma_1^gamma_2^gamma_3 in pseudovector
    GAMMA_1_GAMMA_2_GAMMA_3 = 3,
  } ArrayIndex;
  typedef enum {
    /// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
    coord_gamma_0gamma_1gamma_2_gamma_0gamma_1gamma_3_gamma_0gamma_2gamma_3_gamma_1gamma_2gamma_3
  } CoordinateOrder;

  /// Constructs a new pseudovector with variable coordinates set to 0.
  inline pseudovector() {set();}

  /// Copy constructor.
  inline pseudovector(const pseudovector &A) {set(A);}



  /// Constructs a new pseudovector from mv.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  /// \param filler This argument can have any value; it's role
  /// is only to prevent the compiler from using this constructor as a converter.
  inline pseudovector(mv &A, int filler) {set(A);}

  /// Constructs a new pseudovector. Coordinate values come from 'A'.
  inline pseudovector(const CoordinateOrder co, const double A[4]) {set(co, A);}

  /// Constructs a new pseudovector with each coordinate specified.
  inline pseudovector(const CoordinateOrder co,  double gamma_0_gamma_1_gamma_2, double gamma_0_gamma_1_gamma_3, double gamma_0_gamma_2_gamma_3, double gamma_1_gamma_2_gamma_3) {
    set(co, gamma_0_gamma_1_gamma_2, gamma_0_gamma_1_gamma_3, gamma_0_gamma_2_gamma_3, gamma_1_gamma_2_gamma_3);
  }

  /// Assignment operator (pseudovector).
  inline pseudovector &operator=(const pseudovector &A) {if (this != &A) {set(A);} return *this;}



  /// Assignment operator (mv).
  inline pseudovector &operator=(const mv &A) {set(A); return *this;}


  /// Sets variable coordinates of 'this' to 0.
  void set();
  /// Sets this to 'A'.
  void set(const pseudovector &A);


  /// Sets this to 'A'.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  void set(const mv &A);


  /// Sets this to 'A'.
  void set(const CoordinateOrder, const double A[4]);

  /// Sets this to coordinates specified.
  void set(const CoordinateOrder,  double gamma_0_gamma_1_gamma_2, double gamma_0_gamma_1_gamma_3, double gamma_0_gamma_2_gamma_3, double gamma_1_gamma_2_gamma_3);

  /// returns the absolute largest coordinate.
  double largestCoordinate() const;
  /// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
  double largestBasisBlade(unsigned int &bm) const;


  /// Returns a string representation (const char*) of this multivector.
  /// Not multi-threading safe.
  /// \param fp how floats are printed (e.g., "%f");
  inline const char * c_str(const char *fp = NULL) const {
    static char buf[2048]; // not MT-safe
    return ::SpacetimeAlgebra::c_str(*this, buf, 2048, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  /// Not multi-threading safe.
  inline const char * c_str_f() const {return c_str("%f");}
  /// Returns a string representation (const char*) of this multivector using %e
  /// Not multi-threading safe.
  inline const char * c_str_e() const {return c_str("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
  /// Not multi-threading safe.
  inline const char * c_str_e20() const {return c_str("%2.20e");}

  /// Returns a string representation (const char*) of this multivector.
  inline std::string toString(const char *fp = NULL) const {
    return ::SpacetimeAlgebra::toString(*this, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  inline std::string toString_f() const {return toString("%f");}
  /// Returns a string representation (const char*) of this multivector using %e.
  inline std::string toString_e() const {return toString("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20.
  inline std::string toString_e20() const {return toString("%2.20e");}

  /// Returns the gamma_0^gamma_1^gamma_2 coordinate.
  inline double get_gamma_0_gamma_1_gamma_2() const { return m_c[0];}
  /// Sets the gamma_0^gamma_1^gamma_2 coordinate.
  inline void set_gamma_0_gamma_1_gamma_2(double gamma_0_gamma_1_gamma_2) { m_c[0] = gamma_0_gamma_1_gamma_2;}
  /// Returns the gamma_0^gamma_1^gamma_3 coordinate.
  inline double get_gamma_0_gamma_1_gamma_3() const { return m_c[1];}
  /// Sets the gamma_0^gamma_1^gamma_3 coordinate.
  inline void set_gamma_0_gamma_1_gamma_3(double gamma_0_gamma_1_gamma_3) { m_c[1] = gamma_0_gamma_1_gamma_3;}
  /// Returns the gamma_0^gamma_2^gamma_3 coordinate.
  inline double get_gamma_0_gamma_2_gamma_3() const { return m_c[2];}
  /// Sets the gamma_0^gamma_2^gamma_3 coordinate.
  inline void set_gamma_0_gamma_2_gamma_3(double gamma_0_gamma_2_gamma_3) { m_c[2] = gamma_0_gamma_2_gamma_3;}
  /// Returns the gamma_1^gamma_2^gamma_3 coordinate.
  inline double get_gamma_1_gamma_2_gamma_3() const { return m_c[3];}
  /// Sets the gamma_1^gamma_2^gamma_3 coordinate.
  inline void set_gamma_1_gamma_2_gamma_3(double gamma_1_gamma_2_gamma_3) { m_c[3] = gamma_1_gamma_2_gamma_3;}
  /// Returns the scalar coordinate (which is always 0).
  inline double get_scalar() const { return 0.0;}
  /// Returns array of coordinates.
  inline const double *getC(CoordinateOrder) const { return m_c;}
}; // end of class pseudovector

/// This class can hold a specialized multivector of type spinor.
///
/// The coordinates are stored in type double.
///
/// The variable non-zero coordinates are:
///   - coordinate 1  (array index: SCALAR = 0)
///   - coordinate gamma_0^gamma_1  (array index: GAMMA_0_GAMMA_1 = 1)
///   - coordinate gamma_0^gamma_2  (array index: GAMMA_0_GAMMA_2 = 2)
///   - coordinate gamma_0^gamma_3  (array index: GAMMA_0_GAMMA_3 = 3)
///   - coordinate gamma_1^gamma_2  (array index: GAMMA_1_GAMMA_2 = 4)
///   - coordinate gamma_1^gamma_3  (array index: GAMMA_1_GAMMA_3 = 5)
///   - coordinate gamma_2^gamma_3  (array index: GAMMA_2_GAMMA_3 = 6)
///   - coordinate gamma_0^gamma_1^gamma_2^gamma_3  (array index: GAMMA_0_GAMMA_1_GAMMA_2_GAMMA_3 = 7)
///
/// The type has no constant coordinates.
///
///
class spinor
{
public:
  /// The coordinates (stored in an array).
  double m_c[8]; // 1, gamma_0^gamma_1, gamma_0^gamma_2, gamma_0^gamma_3, gamma_1^gamma_2, gamma_1^gamma_3, gamma_2^gamma_3, gamma_0^gamma_1^gamma_2^gamma_3
public:

  /// Floating point type used by spinor
  typedef double Float;
  /// Array indices of spinor coordinates.
  typedef enum {
    /// index of coordinate for 1 in spinor
    SCALAR = 0,
    /// index of coordinate for gamma_0^gamma_1 in spinor
    GAMMA_0_GAMMA_1 = 1,
    /// index of coordinate for gamma_0^gamma_2 in spinor
    GAMMA_0_GAMMA_2 = 2,
    /// index of coordinate for gamma_0^gamma_3 in spinor
    GAMMA_0_GAMMA_3 = 3,
    /// index of coordinate for gamma_1^gamma_2 in spinor
    GAMMA_1_GAMMA_2 = 4,
    /// index of coordinate for gamma_1^gamma_3 in spinor
    GAMMA_1_GAMMA_3 = 5,
    /// index of coordinate for gamma_2^gamma_3 in spinor
    GAMMA_2_GAMMA_3 = 6,
    /// index of coordinate for gamma_0^gamma_1^gamma_2^gamma_3 in spinor
    GAMMA_0_GAMMA_1_GAMMA_2_GAMMA_3 = 7,
  } ArrayIndex;
  typedef enum {
    /// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
    coord_scalar_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_0gamma_1gamma_2gamma_3
  } CoordinateOrder;

  /// Constructs a new spinor with variable coordinates set to 0.
  inline spinor() {set();}

  /// Copy constructor.
  inline spinor(const spinor &A) {set(A);}


  /// Constructs a new spinor with scalar value 'scalar'.
  inline spinor(double scalar) {set(scalar);}

  /// Constructs a new spinor from mv.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  /// \param filler This argument can have any value; it's role
  /// is only to prevent the compiler from using this constructor as a converter.
  inline spinor(mv &A, int filler) {set(A);}

  /// Constructs a new spinor. Coordinate values come from 'A'.
  inline spinor(const CoordinateOrder co, const double A[8]) {set(co, A);}

  /// Constructs a new spinor with each coordinate specified.
  inline spinor(const CoordinateOrder co,  double scalar, double gamma_0_gamma_1, double gamma_0_gamma_2, double gamma_0_gamma_3, double gamma_1_gamma_2, double gamma_1_gamma_3, double gamma_2_gamma_3, double gamma_0_gamma_1_gamma_2_gamma_3) {
    set(co, scalar, gamma_0_gamma_1, gamma_0_gamma_2, gamma_0_gamma_3, gamma_1_gamma_2, gamma_1_gamma_3, gamma_2_gamma_3, gamma_0_gamma_1_gamma_2_gamma_3);
  }

  /// Assignment operator (spinor).
  inline spinor &operator=(const spinor &A) {if (this != &A) {set(A);} return *this;}


  /// Assignment operator (double).
  inline spinor &operator=(const double &scalar) {set(scalar); return *this;}

  /// Assignment operator (mv).
  inline spinor &operator=(const mv &A) {set(A); return *this;}


  /// Sets variable coordinates of 'this' to 0.
  void set();
  /// Sets this to 'A'.
  void set(const spinor &A);

  /// Sets this to scalar value 'scalar'.
  void set(double scalar);

  /// Sets this to 'A'.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  void set(const mv &A);


  /// Sets this to 'A'.
  void set(const CoordinateOrder, const double A[8]);

  /// Sets this to coordinates specified.
  void set(const CoordinateOrder,  double scalar, double gamma_0_gamma_1, double gamma_0_gamma_2, double gamma_0_gamma_3, double gamma_1_gamma_2, double gamma_1_gamma_3, double gamma_2_gamma_3, double gamma_0_gamma_1_gamma_2_gamma_3);

  /// returns the absolute largest coordinate.
  double largestCoordinate() const;
  /// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
  double largestBasisBlade(unsigned int &bm) const;


  /// Returns a string representation (const char*) of this multivector.
  /// Not multi-threading safe.
  /// \param fp how floats are printed (e.g., "%f");
  inline const char * c_str(const char *fp = NULL) const {
    static char buf[2048]; // not MT-safe
    return ::SpacetimeAlgebra::c_str(*this, buf, 2048, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  /// Not multi-threading safe.
  inline const char * c_str_f() const {return c_str("%f");}
  /// Returns a string representation (const char*) of this multivector using %e
  /// Not multi-threading safe.
  inline const char * c_str_e() const {return c_str("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
  /// Not multi-threading safe.
  inline const char * c_str_e20() const {return c_str("%2.20e");}

  /// Returns a string representation (const char*) of this multivector.
  inline std::string toString(const char *fp = NULL) const {
    return ::SpacetimeAlgebra::toString(*this, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  inline std::string toString_f() const {return toString("%f");}
  /// Returns a string representation (const char*) of this multivector using %e.
  inline std::string toString_e() const {return toString("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20.
  inline std::string toString_e20() const {return toString("%2.20e");}

  /// Returns the 1 coordinate.
  inline double get_scalar() const { return m_c[0];}
  /// Sets the 1 coordinate.
  inline void set_scalar(double scalar) { m_c[0] = scalar;}
  /// Returns the gamma_0^gamma_1 coordinate.
  inline double get_gamma_0_gamma_1() const { return m_c[1];}
  /// Sets the gamma_0^gamma_1 coordinate.
  inline void set_gamma_0_gamma_1(double gamma_0_gamma_1) { m_c[1] = gamma_0_gamma_1;}
  /// Returns the gamma_0^gamma_2 coordinate.
  inline double get_gamma_0_gamma_2() const { return m_c[2];}
  /// Sets the gamma_0^gamma_2 coordinate.
  inline void set_gamma_0_gamma_2(double gamma_0_gamma_2) { m_c[2] = gamma_0_gamma_2;}
  /// Returns the gamma_0^gamma_3 coordinate.
  inline double get_gamma_0_gamma_3() const { return m_c[3];}
  /// Sets the gamma_0^gamma_3 coordinate.
  inline void set_gamma_0_gamma_3(double gamma_0_gamma_3) { m_c[3] = gamma_0_gamma_3;}
  /// Returns the gamma_1^gamma_2 coordinate.
  inline double get_gamma_1_gamma_2() const { return m_c[4];}
  /// Sets the gamma_1^gamma_2 coordinate.
  inline void set_gamma_1_gamma_2(double gamma_1_gamma_2) { m_c[4] = gamma_1_gamma_2;}
  /// Returns the gamma_1^gamma_3 coordinate.
  inline double get_gamma_1_gamma_3() const { return m_c[5];}
  /// Sets the gamma_1^gamma_3 coordinate.
  inline void set_gamma_1_gamma_3(double gamma_1_gamma_3) { m_c[5] = gamma_1_gamma_3;}
  /// Returns the gamma_2^gamma_3 coordinate.
  inline double get_gamma_2_gamma_3() const { return m_c[6];}
  /// Sets the gamma_2^gamma_3 coordinate.
  inline void set_gamma_2_gamma_3(double gamma_2_gamma_3) { m_c[6] = gamma_2_gamma_3;}
  /// Returns the gamma_0^gamma_1^gamma_2^gamma_3 coordinate.
  inline double get_gamma_0_gamma_1_gamma_2_gamma_3() const { return m_c[7];}
  /// Sets the gamma_0^gamma_1^gamma_2^gamma_3 coordinate.
  inline void set_gamma_0_gamma_1_gamma_2_gamma_3(double gamma_0_gamma_1_gamma_2_gamma_3) { m_c[7] = gamma_0_gamma_1_gamma_2_gamma_3;}
  /// Returns array of coordinates.
  inline const double *getC(CoordinateOrder) const { return m_c;}
}; // end of class spinor

/// This class can hold a specialized multivector of type spinor3.
///
/// The coordinates are stored in type double.
///
/// The variable non-zero coordinates are:
///   - coordinate 1  (array index: SCALAR = 0)
///   - coordinate gamma_1^gamma_2  (array index: GAMMA_1_GAMMA_2 = 1)
///   - coordinate gamma_1^gamma_3  (array index: GAMMA_1_GAMMA_3 = 2)
///   - coordinate gamma_2^gamma_3  (array index: GAMMA_2_GAMMA_3 = 3)
///
/// The type has no constant coordinates.
///
///
class spinor3
{
public:
  /// The coordinates (stored in an array).
  double m_c[4]; // 1, gamma_1^gamma_2, gamma_1^gamma_3, gamma_2^gamma_3
public:

  /// Floating point type used by spinor3
  typedef double Float;
  /// Array indices of spinor3 coordinates.
  typedef enum {
    /// index of coordinate for 1 in spinor3
    SCALAR = 0,
    /// index of coordinate for gamma_1^gamma_2 in spinor3
    GAMMA_1_GAMMA_2 = 1,
    /// index of coordinate for gamma_1^gamma_3 in spinor3
    GAMMA_1_GAMMA_3 = 2,
    /// index of coordinate for gamma_2^gamma_3 in spinor3
    GAMMA_2_GAMMA_3 = 3,
  } ArrayIndex;
  typedef enum {
    /// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
    coord_scalar_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3
  } CoordinateOrder;

  /// Constructs a new spinor3 with variable coordinates set to 0.
  inline spinor3() {set();}

  /// Copy constructor.
  inline spinor3(const spinor3 &A) {set(A);}


  /// Constructs a new spinor3 with scalar value 'scalar'.
  inline spinor3(double scalar) {set(scalar);}

  /// Constructs a new spinor3 from mv.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  /// \param filler This argument can have any value; it's role
  /// is only to prevent the compiler from using this constructor as a converter.
  inline spinor3(mv &A, int filler) {set(A);}

  /// Constructs a new spinor3. Coordinate values come from 'A'.
  inline spinor3(const CoordinateOrder co, const double A[4]) {set(co, A);}

  /// Constructs a new spinor3 with each coordinate specified.
  inline spinor3(const CoordinateOrder co,  double scalar, double gamma_1_gamma_2, double gamma_1_gamma_3, double gamma_2_gamma_3) {
    set(co, scalar, gamma_1_gamma_2, gamma_1_gamma_3, gamma_2_gamma_3);
  }

  /// Assignment operator (spinor3).
  inline spinor3 &operator=(const spinor3 &A) {if (this != &A) {set(A);} return *this;}


  /// Assignment operator (double).
  inline spinor3 &operator=(const double &scalar) {set(scalar); return *this;}

  /// Assignment operator (mv).
  inline spinor3 &operator=(const mv &A) {set(A); return *this;}


  /// Sets variable coordinates of 'this' to 0.
  void set();
  /// Sets this to 'A'.
  void set(const spinor3 &A);

  /// Sets this to scalar value 'scalar'.
  void set(double scalar);

  /// Sets this to 'A'.
  /// \param A The value to copy. Coordinates that cannot be represented
  /// are silently dropped.
  void set(const mv &A);


  /// Sets this to 'A'.
  void set(const CoordinateOrder, const double A[4]);

  /// Sets this to coordinates specified.
  void set(const CoordinateOrder,  double scalar, double gamma_1_gamma_2, double gamma_1_gamma_3, double gamma_2_gamma_3);

  /// returns the absolute largest coordinate.
  double largestCoordinate() const;
  /// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
  double largestBasisBlade(unsigned int &bm) const;


  /// Returns a string representation (const char*) of this multivector.
  /// Not multi-threading safe.
  /// \param fp how floats are printed (e.g., "%f");
  inline const char * c_str(const char *fp = NULL) const {
    static char buf[2048]; // not MT-safe
    return ::SpacetimeAlgebra::c_str(*this, buf, 2048, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  /// Not multi-threading safe.
  inline const char * c_str_f() const {return c_str("%f");}
  /// Returns a string representation (const char*) of this multivector using %e
  /// Not multi-threading safe.
  inline const char * c_str_e() const {return c_str("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
  /// Not multi-threading safe.
  inline const char * c_str_e20() const {return c_str("%2.20e");}

  /// Returns a string representation (const char*) of this multivector.
  inline std::string toString(const char *fp = NULL) const {
    return ::SpacetimeAlgebra::toString(*this, fp);
  }

  /// Returns a string representation (const char*) of this multivector using %f.
  inline std::string toString_f() const {return toString("%f");}
  /// Returns a string representation (const char*) of this multivector using %e.
  inline std::string toString_e() const {return toString("%e");}
  /// Returns a string representation (const char*) of this multivector using %e20.
  inline std::string toString_e20() const {return toString("%2.20e");}

  /// Returns the 1 coordinate.
  inline double get_scalar() const { return m_c[0];}
  /// Sets the 1 coordinate.
  inline void set_scalar(double scalar) { m_c[0] = scalar;}
  /// Returns the gamma_1^gamma_2 coordinate.
  inline double get_gamma_1_gamma_2() const { return m_c[1];}
  /// Sets the gamma_1^gamma_2 coordinate.
  inline void set_gamma_1_gamma_2(double gamma_1_gamma_2) { m_c[1] = gamma_1_gamma_2;}
  /// Returns the gamma_1^gamma_3 coordinate.
  inline double get_gamma_1_gamma_3() const { return m_c[2];}
  /// Sets the gamma_1^gamma_3 coordinate.
  inline void set_gamma_1_gamma_3(double gamma_1_gamma_3) { m_c[2] = gamma_1_gamma_3;}
  /// Returns the gamma_2^gamma_3 coordinate.
  inline double get_gamma_2_gamma_3() const { return m_c[3];}
  /// Sets the gamma_2^gamma_3 coordinate.
  inline void set_gamma_2_gamma_3(double gamma_2_gamma_3) { m_c[3] = gamma_2_gamma_3;}
  /// Returns array of coordinates.
  inline const double *getC(CoordinateOrder) const { return m_c;}
}; // end of class spinor3
extern gamma_0_t gamma_0;
extern gamma_1_t gamma_1;
extern gamma_2_t gamma_2;
extern gamma_3_t gamma_3;
extern I_t psI;
extern I3_t I3;


/**
This class is used to report usage of converted specialized multivectors.

The class is designed to be pretty safe with multi-threading without locking.
In the wordt case, some memory leaks occur and some counts are missed.
The amount of memory leaked is bounded (goes not grow beyond a certain
point). Since the report-usage functionality is for
development/debugging only, this is not considered non-harmful.
*/
class ReportUsage {
  /// prints out error message that ReportUsage is disabled
  static void printReport(FILE *F = stdout, bool includeCount = true);
}; // end of class ReportUsage

/** Sets 1 double to zero */
void zero_1(double *dst);
/** Copies 1 double from 'src' to 'dst' */
void copy_1(double *dst, const double *src);
/** Sets 2 doubles to zero */
void zero_2(double *dst);
/** Copies 2 doubles from 'src' to 'dst' */
void copy_2(double *dst, const double *src);
/** Sets 3 doubles to zero */
void zero_3(double *dst);
/** Copies 3 doubles from 'src' to 'dst' */
void copy_3(double *dst, const double *src);
/** Sets 4 doubles to zero */
void zero_4(double *dst);
/** Copies 4 doubles from 'src' to 'dst' */
void copy_4(double *dst, const double *src);
/** Sets 5 doubles to zero */
void zero_5(double *dst);
/** Copies 5 doubles from 'src' to 'dst' */
void copy_5(double *dst, const double *src);
/** Sets 6 doubles to zero */
void zero_6(double *dst);
/** Copies 6 doubles from 'src' to 'dst' */
void copy_6(double *dst, const double *src);
/** Sets 7 doubles to zero */
void zero_7(double *dst);
/** Copies 7 doubles from 'src' to 'dst' */
void copy_7(double *dst, const double *src);
/** Sets 8 doubles to zero */
void zero_8(double *dst);
/** Copies 8 doubles from 'src' to 'dst' */
void copy_8(double *dst, const double *src);
/** Sets 9 doubles to zero */
void zero_9(double *dst);
/** Copies 9 doubles from 'src' to 'dst' */
void copy_9(double *dst, const double *src);
/** Sets 10 doubles to zero */
void zero_10(double *dst);
/** Copies 10 doubles from 'src' to 'dst' */
void copy_10(double *dst, const double *src);
/** Sets 11 doubles to zero */
void zero_11(double *dst);
/** Copies 11 doubles from 'src' to 'dst' */
void copy_11(double *dst, const double *src);
/** Sets 12 doubles to zero */
void zero_12(double *dst);
/** Copies 12 doubles from 'src' to 'dst' */
void copy_12(double *dst, const double *src);
/** Sets 13 doubles to zero */
void zero_13(double *dst);
/** Copies 13 doubles from 'src' to 'dst' */
void copy_13(double *dst, const double *src);
/** Sets 14 doubles to zero */
void zero_14(double *dst);
/** Copies 14 doubles from 'src' to 'dst' */
void copy_14(double *dst, const double *src);
/** Sets 15 doubles to zero */
void zero_15(double *dst);
/** Copies 15 doubles from 'src' to 'dst' */
void copy_15(double *dst, const double *src);
/** Sets 16 doubles to zero */
void zero_16(double *dst);
/** Copies 16 doubles from 'src' to 'dst' */
void copy_16(double *dst, const double *src);
/** Sets N doubles to zero */
void zero_N(double *dst, int N);
/** Copies N doubles from 'src' to 'dst' */
void copy_N(double *dst, const double *src, int N);
// decl SB:

/// Returns scalar part of  mv
double _double(const mv &x);
/// Returns scalar part of  mv
inline double _Float(const mv &x) {return _double(x); };

/// Compresses coordinates 'c' into a new multivector.
/// \param c the coordinates (may already be partially compressed, see argument 'gu').
/// \param epsilon value with a abs magnitude < epsilon are considered to be 0.
/// \param gu optionally specifies which groups/grades are present in 'c'.
mv mv_compress(const double *c, double epsilon = 0.0, int gu = 31);
/// Compresses an array of coordinates/basis blade bitmaps into a new multivector.
mv mv_compress(int nbBlades, const unsigned int *bitmaps, const double *coords);


/// Returns scalar part of  gamma_0_t
double _double(const gamma_0_t &x);
/// Returns scalar part of  gamma_0_t
inline double _Float(const gamma_0_t &x) {return _double(x); };
/// Returns scalar part of  gamma_1_t
double _double(const gamma_1_t &x);
/// Returns scalar part of  gamma_1_t
inline double _Float(const gamma_1_t &x) {return _double(x); };
/// Returns scalar part of  gamma_2_t
double _double(const gamma_2_t &x);
/// Returns scalar part of  gamma_2_t
inline double _Float(const gamma_2_t &x) {return _double(x); };
/// Returns scalar part of  gamma_3_t
double _double(const gamma_3_t &x);
/// Returns scalar part of  gamma_3_t
inline double _Float(const gamma_3_t &x) {return _double(x); };
/// Returns scalar part of  I_t
double _double(const I_t &x);
/// Returns scalar part of  I_t
inline double _Float(const I_t &x) {return _double(x); };
/// Returns scalar part of  I3_t
double _double(const I3_t &x);
/// Returns scalar part of  I3_t
inline double _Float(const I3_t &x) {return _double(x); };
/// Returns scalar part of  mv3
double _double(const mv3 &x);
/// Returns scalar part of  mv3
inline double _Float(const mv3 &x) {return _double(x); };
/// Returns scalar part of  vector
double _double(const vector &x);
/// Returns scalar part of  vector
inline double _Float(const vector &x) {return _double(x); };
/// Returns scalar part of  vector3
double _double(const vector3 &x);
/// Returns scalar part of  vector3
inline double _Float(const vector3 &x) {return _double(x); };
/// Returns scalar part of  bivector
double _double(const bivector &x);
/// Returns scalar part of  bivector
inline double _Float(const bivector &x) {return _double(x); };
/// Returns scalar part of  bivector3
double _double(const bivector3 &x);
/// Returns scalar part of  bivector3
inline double _Float(const bivector3 &x) {return _double(x); };
/// Returns scalar part of  pseudovector
double _double(const pseudovector &x);
/// Returns scalar part of  pseudovector
inline double _Float(const pseudovector &x) {return _double(x); };
/// Returns scalar part of  spinor
double _double(const spinor &x);
/// Returns scalar part of  spinor
inline double _Float(const spinor &x) {return _double(x); };
/// Returns scalar part of  spinor3
double _double(const spinor3 &x);
/// Returns scalar part of  spinor3
inline double _Float(const spinor3 &x) {return _double(x); };
/** Converts vector to vector3: dst = a. */
vector3 _vector3(const vector &a);
/** Converts bivector to bivector3: dst = a. */
bivector3 _bivector3(const bivector &a);
/** Converts spinor to spinor3: dst = a. */
spinor3 _spinor3(const spinor &a);
/// Returns grade groupBitmap of  mv.
mv extractGrade(const mv &a, int groupBitmap);
/// Returns grade 0 of  mv.
mv extractGrade0(const mv &a);
/// Returns grade 0 of  mv3.
double extractGrade0(const mv3 &a);
/// Returns grade 0 of  vector.
double extractGrade0(const vector &a);
/// Returns grade 0 of  vector3.
double extractGrade0(const vector3 &a);
/// Returns grade 0 of  bivector.
double extractGrade0(const bivector &a);
/// Returns grade 0 of  bivector3.
double extractGrade0(const bivector3 &a);
/// Returns grade 0 of  pseudovector.
double extractGrade0(const pseudovector &a);
/// Returns grade 0 of  spinor.
double extractGrade0(const spinor &a);
/// Returns grade 0 of  spinor3.
double extractGrade0(const spinor3 &a);
/// Returns grade 1 of  mv.
mv extractGrade1(const mv &a);
/// Returns grade 1 of  mv3.
vector3 extractGrade1(const mv3 &a);
/// Returns grade 1 of  vector.
vector extractGrade1(const vector &a);
/// Returns grade 1 of  vector3.
vector3 extractGrade1(const vector3 &a);
/// Returns grade 1 of  bivector.
double extractGrade1(const bivector &a);
/// Returns grade 1 of  bivector3.
double extractGrade1(const bivector3 &a);
/// Returns grade 1 of  pseudovector.
double extractGrade1(const pseudovector &a);
/// Returns grade 1 of  spinor.
double extractGrade1(const spinor &a);
/// Returns grade 1 of  spinor3.
double extractGrade1(const spinor3 &a);
/// Returns grade 2 of  mv.
mv extractGrade2(const mv &a);
/// Returns grade 2 of  mv3.
bivector3 extractGrade2(const mv3 &a);
/// Returns grade 2 of  vector.
double extractGrade2(const vector &a);
/// Returns grade 2 of  vector3.
double extractGrade2(const vector3 &a);
/// Returns grade 2 of  bivector.
bivector extractGrade2(const bivector &a);
/// Returns grade 2 of  bivector3.
bivector3 extractGrade2(const bivector3 &a);
/// Returns grade 2 of  pseudovector.
double extractGrade2(const pseudovector &a);
/// Returns grade 2 of  spinor.
bivector extractGrade2(const spinor &a);
/// Returns grade 2 of  spinor3.
bivector3 extractGrade2(const spinor3 &a);
/// Returns grade 3 of  mv.
mv extractGrade3(const mv &a);
/// Returns grade 3 of  mv3.
pseudovector extractGrade3(const mv3 &a);
/// Returns grade 3 of  vector.
double extractGrade3(const vector &a);
/// Returns grade 3 of  vector3.
double extractGrade3(const vector3 &a);
/// Returns grade 3 of  bivector.
double extractGrade3(const bivector &a);
/// Returns grade 3 of  bivector3.
double extractGrade3(const bivector3 &a);
/// Returns grade 3 of  pseudovector.
pseudovector extractGrade3(const pseudovector &a);
/// Returns grade 3 of  spinor.
double extractGrade3(const spinor &a);
/// Returns grade 3 of  spinor3.
double extractGrade3(const spinor3 &a);
/// Returns grade 4 of  mv.
mv extractGrade4(const mv &a);
/// Returns grade 4 of  mv3.
double extractGrade4(const mv3 &a);
/// Returns grade 4 of  vector.
double extractGrade4(const vector &a);
/// Returns grade 4 of  vector3.
double extractGrade4(const vector3 &a);
/// Returns grade 4 of  bivector.
double extractGrade4(const bivector &a);
/// Returns grade 4 of  bivector3.
double extractGrade4(const bivector3 &a);
/// Returns grade 4 of  pseudovector.
double extractGrade4(const pseudovector &a);
/// Returns grade 4 of  spinor.
spinor extractGrade4(const spinor &a);
/// Returns grade 4 of  spinor3.
double extractGrade4(const spinor3 &a);
/// Returns mv + mv.
mv add(const mv &a, const mv &b);
/// Returns mv3 + mv3.
mv3 add(const mv3 &a, const mv3 &b);
/// Returns vector + vector.
vector add(const vector &a, const vector &b);
/// Returns vector3 + vector3.
vector3 add(const vector3 &a, const vector3 &b);
/// Returns bivector + bivector.
bivector add(const bivector &a, const bivector &b);
/// Returns bivector3 + bivector3.
bivector3 add(const bivector3 &a, const bivector3 &b);
/// Returns pseudovector + pseudovector.
pseudovector add(const pseudovector &a, const pseudovector &b);
/// Returns spinor + spinor.
spinor add(const spinor &a, const spinor &b);
/// Returns spinor3 + spinor3.
spinor3 add(const spinor3 &a, const spinor3 &b);
/// Returns mv - mv.
mv subtract(const mv &a, const mv &b);
/// Returns mv3 - mv3.
mv3 subtract(const mv3 &a, const mv3 &b);
/// Returns vector - vector.
vector subtract(const vector &a, const vector &b);
/// Returns vector3 - vector3.
vector3 subtract(const vector3 &a, const vector3 &b);
/// Returns bivector - bivector.
bivector subtract(const bivector &a, const bivector &b);
/// Returns bivector3 - bivector3.
bivector3 subtract(const bivector3 &a, const bivector3 &b);
/// Returns pseudovector - pseudovector.
pseudovector subtract(const pseudovector &a, const pseudovector &b);
/// Returns spinor - spinor.
spinor subtract(const spinor &a, const spinor &b);
/// Returns spinor3 - spinor3.
spinor3 subtract(const spinor3 &a, const spinor3 &b);
/// Returns geometric product of double and mv.
mv gp(const double a, const mv &b);
/// Returns geometric product of double and mv3.
mv3 gp(const double a, const mv3 &b);
/// Returns geometric product of double and vector.
vector gp(const double a, const vector &b);
/// Returns geometric product of double and vector3.
vector3 gp(const double a, const vector3 &b);
/// Returns geometric product of double and bivector.
bivector gp(const double a, const bivector &b);
/// Returns geometric product of double and bivector3.
bivector3 gp(const double a, const bivector3 &b);
/// Returns geometric product of double and pseudovector.
pseudovector gp(const double a, const pseudovector &b);
/// Returns geometric product of double and spinor.
spinor gp(const double a, const spinor &b);
/// Returns geometric product of double and spinor3.
spinor3 gp(const double a, const spinor3 &b);
/// Returns geometric product of mv and double.
mv gp(const mv &a, const double b);
/// Returns geometric product of mv3 and double.
mv3 gp(const mv3 &a, const double b);
/// Returns geometric product of vector and double.
vector gp(const vector &a, const double b);
/// Returns geometric product of vector3 and double.
vector3 gp(const vector3 &a, const double b);
/// Returns geometric product of bivector and double.
bivector gp(const bivector &a, const double b);
/// Returns geometric product of bivector3 and double.
bivector3 gp(const bivector3 &a, const double b);
/// Returns geometric product of pseudovector and double.
pseudovector gp(const pseudovector &a, const double b);
/// Returns geometric product of spinor and double.
spinor gp(const spinor &a, const double b);
/// Returns geometric product of spinor3 and double.
spinor3 gp(const spinor3 &a, const double b);
/// Returns a / b
mv div(const mv &a, const double b);
/// Returns a / b
mv3 div(const mv3 &a, const double b);
/// Returns a / b
vector div(const vector &a, const double b);
/// Returns a / b
vector3 div(const vector3 &a, const double b);
/// Returns a / b
bivector div(const bivector &a, const double b);
/// Returns a / b
bivector3 div(const bivector3 &a, const double b);
/// Returns a / b
pseudovector div(const pseudovector &a, const double b);
/// Returns a / b
spinor div(const spinor &a, const double b);
/// Returns a / b
spinor3 div(const spinor3 &a, const double b);
/// Returns geometric product of mv and mv.
mv gp(const mv &a, const mv &b);
/// Returns geometric product of spinor and spinor.
spinor gp(const spinor &a, const spinor &b);
/// Returns geometric product of spinor3 and spinor3.
spinor3 gp(const spinor3 &a, const spinor3 &b);
/// Returns right contraction of mv and mv.
mv rc(const mv &a, const mv &b);
/// Returns left contraction of mv and mv.
mv lc(const mv &a, const mv &b);
/// Returns scalar product of mv and mv.
double sp(const mv &a, const mv &b);
/// Returns scalar product of mv3 and mv3.
double sp(const mv3 &a, const mv3 &b);
/// Returns scalar product of vector and vector.
double sp(const vector &a, const vector &b);
/// Returns scalar product of vector3 and vector3.
double sp(const vector3 &a, const vector3 &b);
/// Returns scalar product of bivector and bivector.
double sp(const bivector &a, const bivector &b);
/// Returns scalar product of bivector3 and bivector3.
double sp(const bivector3 &a, const bivector3 &b);
/// Returns scalar product of pseudovector and pseudovector.
double sp(const pseudovector &a, const pseudovector &b);
/// Returns scalar product of spinor and spinor.
double sp(const spinor &a, const spinor &b);
/// Returns scalar product of spinor3 and spinor3.
double sp(const spinor3 &a, const spinor3 &b);
/// Returns outer product of mv and mv.
mv op(const mv &a, const mv &b);
/// Returns outer product of vector and vector.
bivector op(const vector &a, const vector &b);
/// Returns outer product of vector3 and vector3.
bivector3 op(const vector3 &a, const vector3 &b);
/// Returns outer product of bivector and bivector.
spinor op(const bivector &a, const bivector &b);
/// Returns outer product of bivector3 and bivector3.
double op(const bivector3 &a, const bivector3 &b);
/// Returns dual of mv using default metric.
mv dual(const mv &a);
/// Returns dual of vector using default metric.
pseudovector dual(const vector &a);
/// Returns dual of bivector using default metric.
bivector dual(const bivector &a);
/// Returns dual of pseudovector using default metric.
vector dual(const pseudovector &a);
/// Returns dual of spinor using default metric.
spinor dual(const spinor &a);
/// Returns negation of mv.
mv negate(const mv &a);
/// Returns negation of mv3.
mv3 negate(const mv3 &a);
/// Returns negation of vector.
vector negate(const vector &a);
/// Returns negation of vector3.
vector3 negate(const vector3 &a);
/// Returns negation of bivector.
bivector negate(const bivector &a);
/// Returns negation of bivector3.
bivector3 negate(const bivector3 &a);
/// Returns negation of pseudovector.
pseudovector negate(const pseudovector &a);
/// Returns negation of spinor.
spinor negate(const spinor &a);
/// Returns negation of spinor3.
spinor3 negate(const spinor3 &a);
/// Returns reverse of mv.
mv reverse(const mv &a);
/// Returns reverse of mv3.
mv3 reverse(const mv3 &a);
/// Returns reverse of vector.
vector reverse(const vector &a);
/// Returns reverse of vector3.
vector3 reverse(const vector3 &a);
/// Returns reverse of bivector.
bivector reverse(const bivector &a);
/// Returns reverse of bivector3.
bivector3 reverse(const bivector3 &a);
/// Returns reverse of pseudovector.
pseudovector reverse(const pseudovector &a);
/// Returns reverse of spinor.
spinor reverse(const spinor &a);
/// Returns reverse of spinor3.
spinor3 reverse(const spinor3 &a);
/// Returns Clifford conjugate of mv.
mv cliffordConjugate(const mv &a);
/// Returns Clifford conjugate of mv3.
mv3 cliffordConjugate(const mv3 &a);
/// Returns Clifford conjugate of vector.
vector cliffordConjugate(const vector &a);
/// Returns Clifford conjugate of vector3.
vector3 cliffordConjugate(const vector3 &a);
/// Returns Clifford conjugate of bivector.
bivector cliffordConjugate(const bivector &a);
/// Returns Clifford conjugate of bivector3.
bivector3 cliffordConjugate(const bivector3 &a);
/// Returns Clifford conjugate of pseudovector.
pseudovector cliffordConjugate(const pseudovector &a);
/// Returns Clifford conjugate of spinor.
spinor cliffordConjugate(const spinor &a);
/// Returns Clifford conjugate of spinor3.
spinor3 cliffordConjugate(const spinor3 &a);
/// Returns grade involution of mv.
mv gradeInvolution(const mv &a);
/// Returns grade involution of mv3.
mv3 gradeInvolution(const mv3 &a);
/// Returns grade involution of vector.
vector gradeInvolution(const vector &a);
/// Returns grade involution of vector3.
vector3 gradeInvolution(const vector3 &a);
/// Returns grade involution of bivector.
bivector gradeInvolution(const bivector &a);
/// Returns grade involution of bivector3.
bivector3 gradeInvolution(const bivector3 &a);
/// Returns grade involution of pseudovector.
pseudovector gradeInvolution(const pseudovector &a);
/// Returns grade involution of spinor.
spinor gradeInvolution(const spinor &a);
/// Returns grade involution of spinor3.
spinor3 gradeInvolution(const spinor3 &a);
/// Returns norm of mv using default metric.
double norm(const mv &a);
/// internal conversion function
double norm_returns_scalar(const mv &a);
/// Returns norm of mv3 using default metric.
double norm(const mv3 &a);
/// internal conversion function
double norm_returns_scalar(const mv3 &a);
/// Returns norm of vector using default metric.
double norm(const vector &a);
/// internal conversion function
double norm_returns_scalar(const vector &a);
/// Returns norm of vector3 using default metric.
double norm(const vector3 &a);
/// internal conversion function
double norm_returns_scalar(const vector3 &a);
/// Returns norm of bivector using default metric.
double norm(const bivector &a);
/// internal conversion function
double norm_returns_scalar(const bivector &a);
/// Returns norm of bivector3 using default metric.
double norm(const bivector3 &a);
/// internal conversion function
double norm_returns_scalar(const bivector3 &a);
/// Returns norm of pseudovector using default metric.
double norm(const pseudovector &a);
/// internal conversion function
double norm_returns_scalar(const pseudovector &a);
/// Returns norm of spinor using default metric.
double norm(const spinor &a);
/// internal conversion function
double norm_returns_scalar(const spinor &a);
/// Returns norm of spinor3 using default metric.
double norm(const spinor3 &a);
/// internal conversion function
double norm_returns_scalar(const spinor3 &a);
/// Returns norm2 of mv using default metric.
double norm2(const mv &a);
/// internal conversion function
double norm2_returns_scalar(const mv &a);
/// Returns norm2 of mv3 using default metric.
double norm2(const mv3 &a);
/// internal conversion function
double norm2_returns_scalar(const mv3 &a);
/// Returns norm2 of vector using default metric.
double norm2(const vector &a);
/// internal conversion function
double norm2_returns_scalar(const vector &a);
/// Returns norm2 of vector3 using default metric.
double norm2(const vector3 &a);
/// internal conversion function
double norm2_returns_scalar(const vector3 &a);
/// Returns norm2 of bivector using default metric.
double norm2(const bivector &a);
/// internal conversion function
double norm2_returns_scalar(const bivector &a);
/// Returns norm2 of bivector3 using default metric.
double norm2(const bivector3 &a);
/// internal conversion function
double norm2_returns_scalar(const bivector3 &a);
/// Returns norm2 of pseudovector using default metric.
double norm2(const pseudovector &a);
/// internal conversion function
double norm2_returns_scalar(const pseudovector &a);
/// Returns norm2 of spinor using default metric.
double norm2(const spinor &a);
/// internal conversion function
double norm2_returns_scalar(const spinor &a);
/// Returns norm2 of spinor3 using default metric.
double norm2(const spinor3 &a);
/// internal conversion function
double norm2_returns_scalar(const spinor3 &a);
/// Returns norm2 of mv using euclidean metric.
double norm2_euclidean(const mv &a);
/// internal conversion function
double norm2_euclidean_returns_scalar(const mv &a);
/// Returns unit of mv using default metric.
mv unit(const mv &a);
/// Returns unit of mv3 using default metric.
mv3 unit(const mv3 &a);
/// Returns unit of vector using default metric.
vector unit(const vector &a);
/// Returns unit of vector3 using default metric.
vector3 unit(const vector3 &a);
/// Returns unit of bivector using default metric.
bivector unit(const bivector &a);
/// Returns unit of bivector3 using default metric.
bivector3 unit(const bivector3 &a);
/// Returns unit of pseudovector using default metric.
pseudovector unit(const pseudovector &a);
/// Returns unit of spinor using default metric.
spinor unit(const spinor &a);
/// Returns unit of spinor3 using default metric.
spinor3 unit(const spinor3 &a);
/// Returns versor inverse of a using default metric.
mv versorInverse(const mv &a);
/// Returns versor inverse of a using default metric.
spinor3 versorInverse(const spinor3 &a);
/// Returns versor inverse of a using default metric.
spinor versorInverse(const spinor &a);
/// Returns double b * mv a + double c.
mv sas(const mv &a, const double b, const double c);
/// Returns double b * spinor3 a + double c.
spinor3 sas(const spinor3 &a, const double b, const double c);
/// Returns double b * spinor a + double c.
spinor sas(const spinor &a, const double b, const double c);
/// Returns logarithm of mv3 using euclidean metric, assuming a 3D Euclidean rotor.
bivector3 log(const mv3 &a);
/// Returns logarithm of spinor3 using euclidean metric, assuming a 3D Euclidean rotor.
bivector3 log(const spinor3 &a);

/** Computes exp of mv.
 */
mv exp(const mv &x, int order = 12);

/** Computes exp of spinor3.
 */
spinor3 exp(const spinor3 &x, int order = 12);

/** Computes exp of spinor.
 */
spinor exp(const spinor &x, int order = 12);

/** Computes sin of mv.
 */
mv sin(const mv &x, int order = 12);

/** Computes sin of spinor3.
 */
spinor3 sin(const spinor3 &x, int order = 12);

/** Computes sin of spinor.
 */
spinor sin(const spinor &x, int order = 12);

/** Computes cos of mv.
 */
mv cos(const mv &x, int order = 12);

/** Computes cos of spinor3.
 */
spinor3 cos(const spinor3 &x, int order = 12);

/** Computes cos of spinor.
 */
spinor cos(const spinor &x, int order = 12);

/** Computes sinh of mv.
 */
mv sinh(const mv &x, int order = 12);

/** Computes sinh of spinor3.
 */
spinor3 sinh(const spinor3 &x, int order = 12);

/** Computes sinh of spinor.
 */
spinor sinh(const spinor &x, int order = 12);

/** Computes cosh of mv.
 */
mv cosh(const mv &x, int order = 12);

/** Computes cosh of spinor3.
 */
spinor3 cosh(const spinor3 &x, int order = 12);

/** Computes cosh of spinor.
 */
spinor cosh(const spinor &x, int order = 12);
/// Returns R * v * inverse(R) using default metric.
vector applyVersor(const spinor &R, const vector &v);
/// Returns R * v * reverse(R) using default metric. Only gives the correct result when the versor has a positive squared norm.
///
vector3 applyUnitVersor(const spinor3 &R, const vector3 &v);
/// returns add(a, b)
inline mv operator+(const mv &a, const mv &b) {
  return add(a, b);
}
/// returns (a = add(a, b))
inline mv &operator+=(mv &a, const mv &b) {
  return (a = add(a, b));
}
/// returns add(a, b)
inline mv3 operator+(const mv3 &a, const mv3 &b) {
  return add(a, b);
}
/// returns (a = add(a, b))
inline mv3 &operator+=(mv3 &a, const mv3 &b) {
  return (a = add(a, b));
}
/// returns add(a, b)
inline vector operator+(const vector &a, const vector &b) {
  return add(a, b);
}
/// returns (a = add(a, b))
inline vector &operator+=(vector &a, const vector &b) {
  return (a = add(a, b));
}
/// returns add(a, b)
inline vector3 operator+(const vector3 &a, const vector3 &b) {
  return add(a, b);
}
/// returns (a = add(a, b))
inline vector3 &operator+=(vector3 &a, const vector3 &b) {
  return (a = add(a, b));
}
/// returns add(a, b)
inline bivector operator+(const bivector &a, const bivector &b) {
  return add(a, b);
}
/// returns (a = add(a, b))
inline bivector &operator+=(bivector &a, const bivector &b) {
  return (a = add(a, b));
}
/// returns add(a, b)
inline bivector3 operator+(const bivector3 &a, const bivector3 &b) {
  return add(a, b);
}
/// returns (a = add(a, b))
inline bivector3 &operator+=(bivector3 &a, const bivector3 &b) {
  return (a = add(a, b));
}
/// returns add(a, b)
inline pseudovector operator+(const pseudovector &a, const pseudovector &b) {
  return add(a, b);
}
/// returns (a = add(a, b))
inline pseudovector &operator+=(pseudovector &a, const pseudovector &b) {
  return (a = add(a, b));
}
/// returns add(a, b)
inline spinor operator+(const spinor &a, const spinor &b) {
  return add(a, b);
}
/// returns (a = add(a, b))
inline spinor &operator+=(spinor &a, const spinor &b) {
  return (a = add(a, b));
}
/// returns add(a, b)
inline spinor3 operator+(const spinor3 &a, const spinor3 &b) {
  return add(a, b);
}
/// returns (a = add(a, b))
inline spinor3 &operator+=(spinor3 &a, const spinor3 &b) {
  return (a = add(a, b));
}
/// returns subtract(a, b)
inline mv operator-(const mv &a, const mv &b) {
  return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline mv &operator-=(mv &a, const mv &b) {
  return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline mv3 operator-(const mv3 &a, const mv3 &b) {
  return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline mv3 &operator-=(mv3 &a, const mv3 &b) {
  return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline vector operator-(const vector &a, const vector &b) {
  return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline vector &operator-=(vector &a, const vector &b) {
  return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline vector3 operator-(const vector3 &a, const vector3 &b) {
  return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline vector3 &operator-=(vector3 &a, const vector3 &b) {
  return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline bivector operator-(const bivector &a, const bivector &b) {
  return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline bivector &operator-=(bivector &a, const bivector &b) {
  return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline bivector3 operator-(const bivector3 &a, const bivector3 &b) {
  return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline bivector3 &operator-=(bivector3 &a, const bivector3 &b) {
  return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline pseudovector operator-(const pseudovector &a, const pseudovector &b) {
  return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline pseudovector &operator-=(pseudovector &a, const pseudovector &b) {
  return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline spinor operator-(const spinor &a, const spinor &b) {
  return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline spinor &operator-=(spinor &a, const spinor &b) {
  return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline spinor3 operator-(const spinor3 &a, const spinor3 &b) {
  return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline spinor3 &operator-=(spinor3 &a, const spinor3 &b) {
  return (a = subtract(a, b));
}
/// returns gp(a, b)
inline mv operator*(const double &a, const mv &b) {
  return gp(a, b);
}
/// returns gp(a, b)
inline mv3 operator*(const double &a, const mv3 &b) {
  return gp(a, b);
}
/// returns gp(a, b)
inline vector operator*(const double &a, const vector &b) {
  return gp(a, b);
}
/// returns gp(a, b)
inline vector3 operator*(const double &a, const vector3 &b) {
  return gp(a, b);
}
/// returns gp(a, b)
inline bivector operator*(const double &a, const bivector &b) {
  return gp(a, b);
}
/// returns gp(a, b)
inline bivector3 operator*(const double &a, const bivector3 &b) {
  return gp(a, b);
}
/// returns gp(a, b)
inline pseudovector operator*(const double &a, const pseudovector &b) {
  return gp(a, b);
}
/// returns gp(a, b)
inline spinor operator*(const double &a, const spinor &b) {
  return gp(a, b);
}
/// returns gp(a, b)
inline spinor3 operator*(const double &a, const spinor3 &b) {
  return gp(a, b);
}
/// returns gp(a, b)
inline mv operator*(const mv &a, const double &b) {
  return gp(a, b);
}
/// returns (a = gp(a, b))
inline mv &operator*=(mv &a, const double &b) {
  return (a = gp(a, b));
}
/// returns gp(a, b)
inline mv3 operator*(const mv3 &a, const double &b) {
  return gp(a, b);
}
/// returns (a = gp(a, b))
inline mv3 &operator*=(mv3 &a, const double &b) {
  return (a = gp(a, b));
}
/// returns gp(a, b)
inline vector operator*(const vector &a, const double &b) {
  return gp(a, b);
}
/// returns (a = gp(a, b))
inline vector &operator*=(vector &a, const double &b) {
  return (a = gp(a, b));
}
/// returns gp(a, b)
inline vector3 operator*(const vector3 &a, const double &b) {
  return gp(a, b);
}
/// returns (a = gp(a, b))
inline vector3 &operator*=(vector3 &a, const double &b) {
  return (a = gp(a, b));
}
/// returns gp(a, b)
inline bivector operator*(const bivector &a, const double &b) {
  return gp(a, b);
}
/// returns (a = gp(a, b))
inline bivector &operator*=(bivector &a, const double &b) {
  return (a = gp(a, b));
}
/// returns gp(a, b)
inline bivector3 operator*(const bivector3 &a, const double &b) {
  return gp(a, b);
}
/// returns (a = gp(a, b))
inline bivector3 &operator*=(bivector3 &a, const double &b) {
  return (a = gp(a, b));
}
/// returns gp(a, b)
inline pseudovector operator*(const pseudovector &a, const double &b) {
  return gp(a, b);
}
/// returns (a = gp(a, b))
inline pseudovector &operator*=(pseudovector &a, const double &b) {
  return (a = gp(a, b));
}
/// returns gp(a, b)
inline spinor operator*(const spinor &a, const double &b) {
  return gp(a, b);
}
/// returns (a = gp(a, b))
inline spinor &operator*=(spinor &a, const double &b) {
  return (a = gp(a, b));
}
/// returns gp(a, b)
inline spinor3 operator*(const spinor3 &a, const double &b) {
  return gp(a, b);
}
/// returns (a = gp(a, b))
inline spinor3 &operator*=(spinor3 &a, const double &b) {
  return (a = gp(a, b));
}
/// returns gp(a, b)
inline mv operator*(const mv &a, const mv &b) {
  return gp(a, b);
}
/// returns (a = gp(a, b))
inline mv &operator*=(mv &a, const mv &b) {
  return (a = gp(a, b));
}
/// returns gp(a, b)
inline spinor operator*(const spinor &a, const spinor &b) {
  return gp(a, b);
}
/// returns (a = gp(a, b))
inline spinor &operator*=(spinor &a, const spinor &b) {
  return (a = gp(a, b));
}
/// returns gp(a, b)
inline spinor3 operator*(const spinor3 &a, const spinor3 &b) {
  return gp(a, b);
}
/// returns (a = gp(a, b))
inline spinor3 &operator*=(spinor3 &a, const spinor3 &b) {
  return (a = gp(a, b));
}
/// returns rc(a, b)
inline mv operator>>(const mv &a, const mv &b) {
  return rc(a, b);
}
/// returns (a = rc(a, b))
inline mv &operator>>=(mv &a, const mv &b) {
  return (a = rc(a, b));
}
/// returns lc(a, b)
inline mv operator<<(const mv &a, const mv &b) {
  return lc(a, b);
}
/// returns (a = lc(a, b))
inline mv &operator<<=(mv &a, const mv &b) {
  return (a = lc(a, b));
}
/// returns sp(a, b)
inline mv operator%(const mv &a, const mv &b) {
  return sp(a, b);
}
/// returns (a = sp(a, b))
inline mv &operator%=(mv &a, const mv &b) {
  return (a = sp(a, b));
}
/// returns sp(a, b)
inline double operator%(const mv3 &a, const mv3 &b) {
  return sp(a, b);
}
/// returns sp(a, b)
inline double operator%(const vector &a, const vector &b) {
  return sp(a, b);
}
/// returns sp(a, b)
inline double operator%(const vector3 &a, const vector3 &b) {
  return sp(a, b);
}
/// returns sp(a, b)
inline double operator%(const bivector &a, const bivector &b) {
  return sp(a, b);
}
/// returns sp(a, b)
inline double operator%(const bivector3 &a, const bivector3 &b) {
  return sp(a, b);
}
/// returns sp(a, b)
inline double operator%(const pseudovector &a, const pseudovector &b) {
  return sp(a, b);
}
/// returns sp(a, b)
inline double operator%(const spinor &a, const spinor &b) {
  return sp(a, b);
}
/// returns sp(a, b)
inline double operator%(const spinor3 &a, const spinor3 &b) {
  return sp(a, b);
}
/// returns op(a, b)
inline mv operator^(const mv &a, const mv &b) {
  return op(a, b);
}
/// returns (a = op(a, b))
inline mv &operator^=(mv &a, const mv &b) {
  return (a = op(a, b));
}
/// returns op(a, b)
inline bivector operator^(const vector &a, const vector &b) {
  return op(a, b);
}
/// returns op(a, b)
inline bivector3 operator^(const vector3 &a, const vector3 &b) {
  return op(a, b);
}
/// returns op(a, b)
inline spinor operator^(const bivector &a, const bivector &b) {
  return op(a, b);
}
/// returns op(a, b)
inline double operator^(const bivector3 &a, const bivector3 &b) {
  return op(a, b);
}
/// returns dual(a)
inline mv operator*(const mv &a) {
  return dual(a);
}
/// returns dual(a)
inline pseudovector operator*(const vector &a) {
  return dual(a);
}
/// returns dual(a)
inline bivector operator*(const bivector &a) {
  return dual(a);
}
/// returns dual(a)
inline vector operator*(const pseudovector &a) {
  return dual(a);
}
/// returns dual(a)
inline spinor operator*(const spinor &a) {
  return dual(a);
}
/// returns negate(a)
inline mv operator-(const mv &a) {
  return negate(a);
}
/// returns negate(a)
inline mv3 operator-(const mv3 &a) {
  return negate(a);
}
/// returns negate(a)
inline vector operator-(const vector &a) {
  return negate(a);
}
/// returns negate(a)
inline vector3 operator-(const vector3 &a) {
  return negate(a);
}
/// returns negate(a)
inline bivector operator-(const bivector &a) {
  return negate(a);
}
/// returns negate(a)
inline bivector3 operator-(const bivector3 &a) {
  return negate(a);
}
/// returns negate(a)
inline pseudovector operator-(const pseudovector &a) {
  return negate(a);
}
/// returns negate(a)
inline spinor operator-(const spinor &a) {
  return negate(a);
}
/// returns negate(a)
inline spinor3 operator-(const spinor3 &a) {
  return negate(a);
}
/// returns reverse(a)
inline mv operator~(const mv &a) {
  return reverse(a);
}
/// returns reverse(a)
inline mv3 operator~(const mv3 &a) {
  return reverse(a);
}
/// returns reverse(a)
inline vector operator~(const vector &a) {
  return reverse(a);
}
/// returns reverse(a)
inline vector3 operator~(const vector3 &a) {
  return reverse(a);
}
/// returns reverse(a)
inline bivector operator~(const bivector &a) {
  return reverse(a);
}
/// returns reverse(a)
inline bivector3 operator~(const bivector3 &a) {
  return reverse(a);
}
/// returns reverse(a)
inline pseudovector operator~(const pseudovector &a) {
  return reverse(a);
}
/// returns reverse(a)
inline spinor operator~(const spinor &a) {
  return reverse(a);
}
/// returns reverse(a)
inline spinor3 operator~(const spinor3 &a) {
  return reverse(a);
}
/// returns versorInverse(a)
inline mv operator!(const mv &a) {
  return versorInverse(a);
}
/// returns versorInverse(a)
inline spinor3 operator!(const spinor3 &a) {
  return versorInverse(a);
}
/// returns versorInverse(a)
inline spinor operator!(const spinor &a) {
  return versorInverse(a);
}

inline void zero_1(double *dst) {
  dst[0]=0.0;
}
inline void copy_1(double *dst, const double *src) {
  dst[0] = src[0];
}
inline void zero_2(double *dst) {
  dst[0]=dst[1]=0.0;
}
inline void copy_2(double *dst, const double *src) {
  dst[0] = src[0];
  dst[1] = src[1];
}
inline void zero_3(double *dst) {
  dst[0]=dst[1]=dst[2]=0.0;
}
inline void copy_3(double *dst, const double *src) {
  dst[0] = src[0];
  dst[1] = src[1];
  dst[2] = src[2];
}
inline void zero_4(double *dst) {
  dst[0]=dst[1]=dst[2]=dst[3]=0.0;
}
inline void copy_4(double *dst, const double *src) {
  dst[0] = src[0];
  dst[1] = src[1];
  dst[2] = src[2];
  dst[3] = src[3];
}
inline void zero_5(double *dst) {
  dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=0.0;
}
inline void copy_5(double *dst, const double *src) {
  dst[0] = src[0];
  dst[1] = src[1];
  dst[2] = src[2];
  dst[3] = src[3];
  dst[4] = src[4];
}
inline void zero_6(double *dst) {
  dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=0.0;
}
inline void copy_6(double *dst, const double *src) {
  dst[0] = src[0];
  dst[1] = src[1];
  dst[2] = src[2];
  dst[3] = src[3];
  dst[4] = src[4];
  dst[5] = src[5];
}
inline void zero_7(double *dst) {
  dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=0.0;
}
inline void copy_7(double *dst, const double *src) {
  dst[0] = src[0];
  dst[1] = src[1];
  dst[2] = src[2];
  dst[3] = src[3];
  dst[4] = src[4];
  dst[5] = src[5];
  dst[6] = src[6];
}
inline void zero_8(double *dst) {
  dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=0.0;
}
inline void copy_8(double *dst, const double *src) {
  dst[0] = src[0];
  dst[1] = src[1];
  dst[2] = src[2];
  dst[3] = src[3];
  dst[4] = src[4];
  dst[5] = src[5];
  dst[6] = src[6];
  dst[7] = src[7];
}
inline void zero_9(double *dst) {
  dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=0.0;
}
inline void copy_9(double *dst, const double *src) {
  dst[0] = src[0];
  dst[1] = src[1];
  dst[2] = src[2];
  dst[3] = src[3];
  dst[4] = src[4];
  dst[5] = src[5];
  dst[6] = src[6];
  dst[7] = src[7];
  dst[8] = src[8];
}
inline void zero_10(double *dst) {
  dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=0.0;
}
inline void copy_10(double *dst, const double *src) {
  dst[0] = src[0];
  dst[1] = src[1];
  dst[2] = src[2];
  dst[3] = src[3];
  dst[4] = src[4];
  dst[5] = src[5];
  dst[6] = src[6];
  dst[7] = src[7];
  dst[8] = src[8];
  dst[9] = src[9];
}
inline void zero_11(double *dst) {
  dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=0.0;
}
inline void copy_11(double *dst, const double *src) {
  dst[0] = src[0];
  dst[1] = src[1];
  dst[2] = src[2];
  dst[3] = src[3];
  dst[4] = src[4];
  dst[5] = src[5];
  dst[6] = src[6];
  dst[7] = src[7];
  dst[8] = src[8];
  dst[9] = src[9];
  dst[10] = src[10];
}
inline void zero_12(double *dst) {
  dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=0.0;
}
inline void copy_12(double *dst, const double *src) {
  dst[0] = src[0];
  dst[1] = src[1];
  dst[2] = src[2];
  dst[3] = src[3];
  dst[4] = src[4];
  dst[5] = src[5];
  dst[6] = src[6];
  dst[7] = src[7];
  dst[8] = src[8];
  dst[9] = src[9];
  dst[10] = src[10];
  dst[11] = src[11];
}
inline void zero_13(double *dst) {
  dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=0.0;
}
inline void copy_13(double *dst, const double *src) {
  dst[0] = src[0];
  dst[1] = src[1];
  dst[2] = src[2];
  dst[3] = src[3];
  dst[4] = src[4];
  dst[5] = src[5];
  dst[6] = src[6];
  dst[7] = src[7];
  dst[8] = src[8];
  dst[9] = src[9];
  dst[10] = src[10];
  dst[11] = src[11];
  dst[12] = src[12];
}
inline void zero_14(double *dst) {
  dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=0.0;
}
inline void copy_14(double *dst, const double *src) {
  dst[0] = src[0];
  dst[1] = src[1];
  dst[2] = src[2];
  dst[3] = src[3];
  dst[4] = src[4];
  dst[5] = src[5];
  dst[6] = src[6];
  dst[7] = src[7];
  dst[8] = src[8];
  dst[9] = src[9];
  dst[10] = src[10];
  dst[11] = src[11];
  dst[12] = src[12];
  dst[13] = src[13];
}
inline void zero_15(double *dst) {
  dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=dst[14]=0.0;
}
inline void copy_15(double *dst, const double *src) {
  dst[0] = src[0];
  dst[1] = src[1];
  dst[2] = src[2];
  dst[3] = src[3];
  dst[4] = src[4];
  dst[5] = src[5];
  dst[6] = src[6];
  dst[7] = src[7];
  dst[8] = src[8];
  dst[9] = src[9];
  dst[10] = src[10];
  dst[11] = src[11];
  dst[12] = src[12];
  dst[13] = src[13];
  dst[14] = src[14];
}
inline void zero_16(double *dst) {
  dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=dst[14]=dst[15]=0.0;
}
inline void copy_16(double *dst, const double *src) {
  dst[0] = src[0];
  dst[1] = src[1];
  dst[2] = src[2];
  dst[3] = src[3];
  dst[4] = src[4];
  dst[5] = src[5];
  dst[6] = src[6];
  dst[7] = src[7];
  dst[8] = src[8];
  dst[9] = src[9];
  dst[10] = src[10];
  dst[11] = src[11];
  dst[12] = src[12];
  dst[13] = src[13];
  dst[14] = src[14];
  dst[15] = src[15];
}
/** Sets N doubles to zero */
inline void zero_N(double *dst, int N) {
  int i = 0;
  while ((N-i) > 16) {
    zero_16(dst + i);
    i += 16;
  }
  for (; i < N; i++)
    dst[i] = 0.0;
}
/** Copies N doubles from 'src' to 'dst' */
inline void copy_N(double *dst, const double *src, int N) {
  int i = 0;
  while ((N-i) > 16) {
    copy_16(dst + i, src + i);
    i += 16;
  }
  for (; i < N; i++)
    dst[i] = src[i];
}
// inline def SB:
inline void mv::set() {
  setGroupUsage(0);
}
inline void mv::set(double val) {
  setGroupUsage(1);
  m_c[0] = val;
}
inline void mv::set(int gu, const double *arr) {
  setGroupUsage(gu);
  SpacetimeAlgebra::copy_N(m_c, arr, SpacetimeAlgebra_mvSize[gu]);

}
inline void mv::set(const mv &src) {
  setGroupUsage(src.gu());
  const double*srcC = src.getC();
  SpacetimeAlgebra::copy_N(m_c, srcC, SpacetimeAlgebra_mvSize[src.gu()]);

}
inline void gamma_0_t::set(const mv &src) {
  const double *ptr = src.getC();

  if (src.gu() & 1) {
    ptr += 1;
  }
  if (src.gu() & 2) {
  }
  else {
  }
}
inline void gamma_1_t::set(const mv &src) {
  const double *ptr = src.getC();

  if (src.gu() & 1) {
    ptr += 1;
  }
  if (src.gu() & 2) {
  }
  else {
  }
}
inline void gamma_2_t::set(const mv &src) {
  const double *ptr = src.getC();

  if (src.gu() & 1) {
    ptr += 1;
  }
  if (src.gu() & 2) {
  }
  else {
  }
}
inline void gamma_3_t::set(const mv &src) {
  const double *ptr = src.getC();

  if (src.gu() & 1) {
    ptr += 1;
  }
  if (src.gu() & 2) {
  }
  else {
  }
}
inline void I_t::set(const mv &src) {
  const double *ptr = src.getC();

  if (src.gu() & 1) {
    ptr += 1;
  }
  if (src.gu() & 2) {
    ptr += 4;
  }
  if (src.gu() & 4) {
    ptr += 6;
  }
  if (src.gu() & 8) {
    ptr += 4;
  }
  if (src.gu() & 16) {
  }
  else {
  }
}
inline void I3_t::set(const mv &src) {
  const double *ptr = src.getC();

  if (src.gu() & 1) {
    ptr += 1;
  }
  if (src.gu() & 2) {
    ptr += 4;
  }
  if (src.gu() & 4) {
    ptr += 6;
  }
  if (src.gu() & 8) {
  }
  else {
  }
}
inline void mv3::set(const mv &src) {
  const double *ptr = src.getC();

  if (src.gu() & 1) {
    m_c[0] = ptr[0];
    ptr += 1;
  }
  else {
    m_c[0] = 0.0;
  }
  if (src.gu() & 2) {
    m_c[1] = ptr[1];
    m_c[2] = ptr[2];
    m_c[3] = ptr[3];
    ptr += 4;
  }
  else {
    m_c[1] = 0.0;
    m_c[2] = 0.0;
    m_c[3] = 0.0;
  }
  if (src.gu() & 4) {
    m_c[4] = ptr[2];
    m_c[5] = ptr[4];
    m_c[6] = ptr[5];
    ptr += 6;
  }
  else {
    m_c[4] = 0.0;
    m_c[5] = 0.0;
    m_c[6] = 0.0;
  }
  if (src.gu() & 8) {
    m_c[7] = ptr[3];
  }
  else {
    m_c[7] = 0.0;
  }
}
inline void vector::set(const mv &src) {
  const double *ptr = src.getC();

  if (src.gu() & 1) {
    ptr += 1;
  }
  if (src.gu() & 2) {
    m_c[0] = ptr[0];
    m_c[1] = ptr[1];
    m_c[2] = ptr[2];
    m_c[3] = ptr[3];
  }
  else {
    m_c[0] = 0.0;
    m_c[1] = 0.0;
    m_c[2] = 0.0;
    m_c[3] = 0.0;
  }
}
inline void vector3::set(const mv &src) {
  const double *ptr = src.getC();

  if (src.gu() & 1) {
    ptr += 1;
  }
  if (src.gu() & 2) {
    m_c[0] = ptr[1];
    m_c[1] = ptr[2];
    m_c[2] = ptr[3];
  }
  else {
    m_c[0] = 0.0;
    m_c[1] = 0.0;
    m_c[2] = 0.0;
  }
}
inline void bivector::set(const mv &src) {
  const double *ptr = src.getC();

  if (src.gu() & 1) {
    ptr += 1;
  }
  if (src.gu() & 2) {
    ptr += 4;
  }
  if (src.gu() & 4) {
    m_c[0] = ptr[0];
    m_c[1] = ptr[1];
    m_c[2] = ptr[3];
    m_c[3] = ptr[2];
    m_c[4] = ptr[4];
    m_c[5] = ptr[5];
  }
  else {
    m_c[0] = 0.0;
    m_c[1] = 0.0;
    m_c[2] = 0.0;
    m_c[3] = 0.0;
    m_c[4] = 0.0;
    m_c[5] = 0.0;
  }
}
inline void bivector3::set(const mv &src) {
  const double *ptr = src.getC();

  if (src.gu() & 1) {
    ptr += 1;
  }
  if (src.gu() & 2) {
    ptr += 4;
  }
  if (src.gu() & 4) {
    m_c[0] = ptr[2];
    m_c[1] = ptr[4];
    m_c[2] = ptr[5];
  }
  else {
    m_c[0] = 0.0;
    m_c[1] = 0.0;
    m_c[2] = 0.0;
  }
}
inline void pseudovector::set(const mv &src) {
  const double *ptr = src.getC();

  if (src.gu() & 1) {
    ptr += 1;
  }
  if (src.gu() & 2) {
    ptr += 4;
  }
  if (src.gu() & 4) {
    ptr += 6;
  }
  if (src.gu() & 8) {
    m_c[0] = ptr[0];
    m_c[1] = ptr[1];
    m_c[2] = ptr[2];
    m_c[3] = ptr[3];
  }
  else {
    m_c[0] = 0.0;
    m_c[1] = 0.0;
    m_c[2] = 0.0;
    m_c[3] = 0.0;
  }
}
inline void spinor::set(const mv &src) {
  const double *ptr = src.getC();

  if (src.gu() & 1) {
    m_c[0] = ptr[0];
    ptr += 1;
  }
  else {
    m_c[0] = 0.0;
  }
  if (src.gu() & 2) {
    ptr += 4;
  }
  if (src.gu() & 4) {
    m_c[1] = ptr[0];
    m_c[2] = ptr[1];
    m_c[3] = ptr[3];
    m_c[4] = ptr[2];
    m_c[5] = ptr[4];
    m_c[6] = ptr[5];
    ptr += 6;
  }
  else {
    m_c[1] = 0.0;
    m_c[2] = 0.0;
    m_c[3] = 0.0;
    m_c[4] = 0.0;
    m_c[5] = 0.0;
    m_c[6] = 0.0;
  }
  if (src.gu() & 8) {
    ptr += 4;
  }
  if (src.gu() & 16) {
    m_c[7] = ptr[0];
  }
  else {
    m_c[7] = 0.0;
  }
}
inline void spinor3::set(const mv &src) {
  const double *ptr = src.getC();

  if (src.gu() & 1) {
    m_c[0] = ptr[0];
    ptr += 1;
  }
  else {
    m_c[0] = 0.0;
  }
  if (src.gu() & 2) {
    ptr += 4;
  }
  if (src.gu() & 4) {
    m_c[1] = ptr[2];
    m_c[2] = ptr[4];
    m_c[3] = ptr[5];
  }
  else {
    m_c[1] = 0.0;
    m_c[2] = 0.0;
    m_c[3] = 0.0;
  }
}
inline void mv::set(const gamma_0_t &src) {
  setGroupUsage(2);
  double *ptr = m_c;
  ptr[0] = 1.0;
  ptr[1] = ptr[2] = ptr[3] = 0.0;
}
inline void mv::set(const gamma_1_t &src) {
  setGroupUsage(2);
  double *ptr = m_c;
  ptr[0] = ptr[2] = ptr[3] = 0.0;
  ptr[1] = 1.0;
}
inline void mv::set(const gamma_2_t &src) {
  setGroupUsage(2);
  double *ptr = m_c;
  ptr[0] = ptr[1] = ptr[3] = 0.0;
  ptr[2] = 1.0;
}
inline void mv::set(const gamma_3_t &src) {
  setGroupUsage(2);
  double *ptr = m_c;
  ptr[0] = ptr[1] = ptr[2] = 0.0;
  ptr[3] = 1.0;
}
inline void mv::set(const I_t &src) {
  setGroupUsage(16);
  double *ptr = m_c;
  ptr[0] = 1.0;
}
inline void mv::set(const I3_t &src) {
  setGroupUsage(8);
  double *ptr = m_c;
  ptr[0] = ptr[1] = ptr[2] = 0.0;
  ptr[3] = 1.0;
}
inline void mv::set(const mv3 &src) {
  setGroupUsage(15);
  double *ptr = m_c;
  ptr[0] = src.m_c[0];
  ptr += 1;
  ptr[0] = 0.0;
  ptr[1] = src.m_c[1];
  ptr[2] = src.m_c[2];
  ptr[3] = src.m_c[3];
  ptr += 4;
  ptr[0] = ptr[1] = ptr[3] = 0.0;
  ptr[2] = src.m_c[4];
  ptr[4] = src.m_c[5];
  ptr[5] = src.m_c[6];
  ptr += 6;
  ptr[0] = ptr[1] = ptr[2] = 0.0;
  ptr[3] = src.m_c[7];
}
inline void mv::set(const vector &src) {
  setGroupUsage(2);
  double *ptr = m_c;
  ptr[0] = src.m_c[0];
  ptr[1] = src.m_c[1];
  ptr[2] = src.m_c[2];
  ptr[3] = src.m_c[3];
}
inline void mv::set(const vector3 &src) {
  setGroupUsage(2);
  double *ptr = m_c;
  ptr[0] = 0.0;
  ptr[1] = src.m_c[0];
  ptr[2] = src.m_c[1];
  ptr[3] = src.m_c[2];
}
inline void mv::set(const bivector &src) {
  setGroupUsage(4);
  double *ptr = m_c;
  ptr[0] = src.m_c[0];
  ptr[1] = src.m_c[1];
  ptr[2] = src.m_c[3];
  ptr[3] = src.m_c[2];
  ptr[4] = src.m_c[4];
  ptr[5] = src.m_c[5];
}
inline void mv::set(const bivector3 &src) {
  setGroupUsage(4);
  double *ptr = m_c;
  ptr[0] = ptr[1] = ptr[3] = 0.0;
  ptr[2] = src.m_c[0];
  ptr[4] = src.m_c[1];
  ptr[5] = src.m_c[2];
}
inline void mv::set(const pseudovector &src) {
  setGroupUsage(8);
  double *ptr = m_c;
  ptr[0] = src.m_c[0];
  ptr[1] = src.m_c[1];
  ptr[2] = src.m_c[2];
  ptr[3] = src.m_c[3];
}
inline void mv::set(const spinor &src) {
  setGroupUsage(21);
  double *ptr = m_c;
  ptr[0] = src.m_c[0];
  ptr += 1;
  ptr[0] = src.m_c[1];
  ptr[1] = src.m_c[2];
  ptr[2] = src.m_c[4];
  ptr[3] = src.m_c[3];
  ptr[4] = src.m_c[5];
  ptr[5] = src.m_c[6];
  ptr += 6;
  ptr[0] = src.m_c[7];
}
inline void mv::set(const spinor3 &src) {
  setGroupUsage(5);
  double *ptr = m_c;
  ptr[0] = src.m_c[0];
  ptr += 1;
  ptr[0] = ptr[1] = ptr[3] = 0.0;
  ptr[2] = src.m_c[1];
  ptr[4] = src.m_c[2];
  ptr[5] = src.m_c[3];
}

inline double _double(const mv &x) {
  return ((x.gu() & 1) != 0) ? x.getC()[0] : 0.0;
}

inline void mv3::set()
{
  m_c[0] = m_c[1] = m_c[2] = m_c[3] = m_c[4] = m_c[5] = m_c[6] = m_c[7] = 0.0;

}
inline void vector::set()
{
  m_c[0] = m_c[1] = m_c[2] = m_c[3] = 0.0;

}
inline void vector3::set()
{
  m_c[0] = m_c[1] = m_c[2] = 0.0;

}
inline void bivector::set()
{
  m_c[0] = m_c[1] = m_c[2] = m_c[3] = m_c[4] = m_c[5] = 0.0;

}
inline void bivector3::set()
{
  m_c[0] = m_c[1] = m_c[2] = 0.0;

}
inline void pseudovector::set()
{
  m_c[0] = m_c[1] = m_c[2] = m_c[3] = 0.0;

}
inline void spinor::set()
{
  m_c[0] = m_c[1] = m_c[2] = m_c[3] = m_c[4] = m_c[5] = m_c[6] = m_c[7] = 0.0;

}
inline void spinor3::set()
{
  m_c[0] = m_c[1] = m_c[2] = m_c[3] = 0.0;

}

inline void mv3::set(const double scalarVal)
{
  m_c[0] = scalarVal;
  m_c[1] = m_c[2] = m_c[3] = m_c[4] = m_c[5] = m_c[6] = m_c[7] = 0.0;

}
inline void spinor::set(const double scalarVal)
{
  m_c[0] = scalarVal;
  m_c[1] = m_c[2] = m_c[3] = m_c[4] = m_c[5] = m_c[6] = m_c[7] = 0.0;

}
inline void spinor3::set(const double scalarVal)
{
  m_c[0] = scalarVal;
  m_c[1] = m_c[2] = m_c[3] = 0.0;

}

inline void mv3::set(const CoordinateOrder co, const double _scalar, const double _gamma_1, const double _gamma_2, const double _gamma_3, const double _gamma_1_gamma_2, const double _gamma_1_gamma_3, const double _gamma_2_gamma_3, const double _gamma_1_gamma_2_gamma_3)
{
  m_c[0] = _scalar;
  m_c[1] = _gamma_1;
  m_c[2] = _gamma_2;
  m_c[3] = _gamma_3;
  m_c[4] = _gamma_1_gamma_2;
  m_c[5] = _gamma_1_gamma_3;
  m_c[6] = _gamma_2_gamma_3;
  m_c[7] = _gamma_1_gamma_2_gamma_3;

}
inline void vector::set(const CoordinateOrder co, const double _gamma_0, const double _gamma_1, const double _gamma_2, const double _gamma_3)
{
  m_c[0] = _gamma_0;
  m_c[1] = _gamma_1;
  m_c[2] = _gamma_2;
  m_c[3] = _gamma_3;

}
inline void vector3::set(const CoordinateOrder co, const double _gamma_1, const double _gamma_2, const double _gamma_3)
{
  m_c[0] = _gamma_1;
  m_c[1] = _gamma_2;
  m_c[2] = _gamma_3;

}
inline void bivector::set(const CoordinateOrder co, const double _gamma_0_gamma_1, const double _gamma_0_gamma_2, const double _gamma_0_gamma_3, const double _gamma_1_gamma_2, const double _gamma_1_gamma_3, const double _gamma_2_gamma_3)
{
  m_c[0] = _gamma_0_gamma_1;
  m_c[1] = _gamma_0_gamma_2;
  m_c[2] = _gamma_0_gamma_3;
  m_c[3] = _gamma_1_gamma_2;
  m_c[4] = _gamma_1_gamma_3;
  m_c[5] = _gamma_2_gamma_3;

}
inline void bivector3::set(const CoordinateOrder co, const double _gamma_1_gamma_2, const double _gamma_1_gamma_3, const double _gamma_2_gamma_3)
{
  m_c[0] = _gamma_1_gamma_2;
  m_c[1] = _gamma_1_gamma_3;
  m_c[2] = _gamma_2_gamma_3;

}
inline void pseudovector::set(const CoordinateOrder co, const double _gamma_0_gamma_1_gamma_2, const double _gamma_0_gamma_1_gamma_3, const double _gamma_0_gamma_2_gamma_3, const double _gamma_1_gamma_2_gamma_3)
{
  m_c[0] = _gamma_0_gamma_1_gamma_2;
  m_c[1] = _gamma_0_gamma_1_gamma_3;
  m_c[2] = _gamma_0_gamma_2_gamma_3;
  m_c[3] = _gamma_1_gamma_2_gamma_3;

}
inline void spinor::set(const CoordinateOrder co, const double _scalar, const double _gamma_0_gamma_1, const double _gamma_0_gamma_2, const double _gamma_0_gamma_3, const double _gamma_1_gamma_2, const double _gamma_1_gamma_3, const double _gamma_2_gamma_3, const double _gamma_0_gamma_1_gamma_2_gamma_3)
{
  m_c[0] = _scalar;
  m_c[1] = _gamma_0_gamma_1;
  m_c[2] = _gamma_0_gamma_2;
  m_c[3] = _gamma_0_gamma_3;
  m_c[4] = _gamma_1_gamma_2;
  m_c[5] = _gamma_1_gamma_3;
  m_c[6] = _gamma_2_gamma_3;
  m_c[7] = _gamma_0_gamma_1_gamma_2_gamma_3;

}
inline void spinor3::set(const CoordinateOrder co, const double _scalar, const double _gamma_1_gamma_2, const double _gamma_1_gamma_3, const double _gamma_2_gamma_3)
{
  m_c[0] = _scalar;
  m_c[1] = _gamma_1_gamma_2;
  m_c[2] = _gamma_1_gamma_3;
  m_c[3] = _gamma_2_gamma_3;

}

inline void mv3::set(const CoordinateOrder co, const double *A)
{
  m_c[0] = A[0];
  m_c[1] = A[1];
  m_c[2] = A[2];
  m_c[3] = A[3];
  m_c[4] = A[4];
  m_c[5] = A[5];
  m_c[6] = A[6];
  m_c[7] = A[7];

}
inline void vector::set(const CoordinateOrder co, const double *A)
{
  m_c[0] = A[0];
  m_c[1] = A[1];
  m_c[2] = A[2];
  m_c[3] = A[3];

}
inline void vector3::set(const CoordinateOrder co, const double *A)
{
  m_c[0] = A[0];
  m_c[1] = A[1];
  m_c[2] = A[2];

}
inline void bivector::set(const CoordinateOrder co, const double *A)
{
  m_c[0] = A[0];
  m_c[1] = A[1];
  m_c[2] = A[2];
  m_c[3] = A[3];
  m_c[4] = A[4];
  m_c[5] = A[5];

}
inline void bivector3::set(const CoordinateOrder co, const double *A)
{
  m_c[0] = A[0];
  m_c[1] = A[1];
  m_c[2] = A[2];

}
inline void pseudovector::set(const CoordinateOrder co, const double *A)
{
  m_c[0] = A[0];
  m_c[1] = A[1];
  m_c[2] = A[2];
  m_c[3] = A[3];

}
inline void spinor::set(const CoordinateOrder co, const double *A)
{
  m_c[0] = A[0];
  m_c[1] = A[1];
  m_c[2] = A[2];
  m_c[3] = A[3];
  m_c[4] = A[4];
  m_c[5] = A[5];
  m_c[6] = A[6];
  m_c[7] = A[7];

}
inline void spinor3::set(const CoordinateOrder co, const double *A)
{
  m_c[0] = A[0];
  m_c[1] = A[1];
  m_c[2] = A[2];
  m_c[3] = A[3];

}

inline void gamma_0_t::set(const gamma_0_t &a)
{

}
inline void gamma_1_t::set(const gamma_1_t &a)
{

}
inline void gamma_2_t::set(const gamma_2_t &a)
{

}
inline void gamma_3_t::set(const gamma_3_t &a)
{

}
inline void I_t::set(const I_t &a)
{

}
inline void I3_t::set(const I3_t &a)
{

}
inline void mv3::set(const mv3 &a)
{
  m_c[0] = a.m_c[0];
  m_c[1] = a.m_c[1];
  m_c[2] = a.m_c[2];
  m_c[3] = a.m_c[3];
  m_c[4] = a.m_c[4];
  m_c[5] = a.m_c[5];
  m_c[6] = a.m_c[6];
  m_c[7] = a.m_c[7];

}
inline void vector::set(const vector &a)
{
  m_c[0] = a.m_c[0];
  m_c[1] = a.m_c[1];
  m_c[2] = a.m_c[2];
  m_c[3] = a.m_c[3];

}
inline void vector3::set(const vector3 &a)
{
  m_c[0] = a.m_c[0];
  m_c[1] = a.m_c[1];
  m_c[2] = a.m_c[2];

}
inline void bivector::set(const bivector &a)
{
  m_c[0] = a.m_c[0];
  m_c[1] = a.m_c[1];
  m_c[2] = a.m_c[2];
  m_c[3] = a.m_c[3];
  m_c[4] = a.m_c[4];
  m_c[5] = a.m_c[5];

}
inline void bivector3::set(const bivector3 &a)
{
  m_c[0] = a.m_c[0];
  m_c[1] = a.m_c[1];
  m_c[2] = a.m_c[2];

}
inline void pseudovector::set(const pseudovector &a)
{
  m_c[0] = a.m_c[0];
  m_c[1] = a.m_c[1];
  m_c[2] = a.m_c[2];
  m_c[3] = a.m_c[3];

}
inline void spinor::set(const spinor &a)
{
  m_c[0] = a.m_c[0];
  m_c[1] = a.m_c[1];
  m_c[2] = a.m_c[2];
  m_c[3] = a.m_c[3];
  m_c[4] = a.m_c[4];
  m_c[5] = a.m_c[5];
  m_c[6] = a.m_c[6];
  m_c[7] = a.m_c[7];

}
inline void spinor3::set(const spinor3 &a)
{
  m_c[0] = a.m_c[0];
  m_c[1] = a.m_c[1];
  m_c[2] = a.m_c[2];
  m_c[3] = a.m_c[3];

}


inline double gamma_0_t::largestCoordinate() const {
  double maxValue = 1.0;
  return maxValue;
}
inline double gamma_0_t::largestBasisBlade(unsigned int &bm) const {
  double maxValue = 1.0;
  bm = 1;
  return maxValue;
}
inline double gamma_1_t::largestCoordinate() const {
  double maxValue = 1.0;
  return maxValue;
}
inline double gamma_1_t::largestBasisBlade(unsigned int &bm) const {
  double maxValue = 1.0;
  bm = 2;
  return maxValue;
}
inline double gamma_2_t::largestCoordinate() const {
  double maxValue = 1.0;
  return maxValue;
}
inline double gamma_2_t::largestBasisBlade(unsigned int &bm) const {
  double maxValue = 1.0;
  bm = 4;
  return maxValue;
}
inline double gamma_3_t::largestCoordinate() const {
  double maxValue = 1.0;
  return maxValue;
}
inline double gamma_3_t::largestBasisBlade(unsigned int &bm) const {
  double maxValue = 1.0;
  bm = 8;
  return maxValue;
}
inline double I_t::largestCoordinate() const {
  double maxValue = 1.0;
  return maxValue;
}
inline double I_t::largestBasisBlade(unsigned int &bm) const {
  double maxValue = 1.0;
  bm = 15;
  return maxValue;
}
inline double I3_t::largestCoordinate() const {
  double maxValue = 1.0;
  return maxValue;
}
inline double I3_t::largestBasisBlade(unsigned int &bm) const {
  double maxValue = 1.0;
  bm = 14;
  return maxValue;
}
inline double mv3::largestCoordinate() const {
  double maxValue = ::fabs(m_c[0]);
  if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); }
  if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); }
  if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); }
  if (::fabs(m_c[4]) > maxValue) { maxValue = ::fabs(m_c[4]); }
  if (::fabs(m_c[5]) > maxValue) { maxValue = ::fabs(m_c[5]); }
  if (::fabs(m_c[6]) > maxValue) { maxValue = ::fabs(m_c[6]); }
  if (::fabs(m_c[7]) > maxValue) { maxValue = ::fabs(m_c[7]); }
  return maxValue;
}
inline double mv3::largestBasisBlade(unsigned int &bm) const {
  double maxValue = ::fabs(m_c[0]);
  bm = 0;
  if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); bm = 2; }
  if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); bm = 4; }
  if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); bm = 8; }
  if (::fabs(m_c[4]) > maxValue) { maxValue = ::fabs(m_c[4]); bm = 6; }
  if (::fabs(m_c[5]) > maxValue) { maxValue = ::fabs(m_c[5]); bm = 10; }
  if (::fabs(m_c[6]) > maxValue) { maxValue = ::fabs(m_c[6]); bm = 12; }
  if (::fabs(m_c[7]) > maxValue) { maxValue = ::fabs(m_c[7]); bm = 14; }
  return maxValue;
}
inline double vector::largestCoordinate() const {
  double maxValue = ::fabs(m_c[0]);
  if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); }
  if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); }
  if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); }
  return maxValue;
}
inline double vector::largestBasisBlade(unsigned int &bm) const {
  double maxValue = ::fabs(m_c[0]);
  bm = 0;
  if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); bm = 2; }
  if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); bm = 4; }
  if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); bm = 8; }
  return maxValue;
}
inline double vector3::largestCoordinate() const {
  double maxValue = ::fabs(m_c[0]);
  if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); }
  if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); }
  return maxValue;
}
inline double vector3::largestBasisBlade(unsigned int &bm) const {
  double maxValue = ::fabs(m_c[0]);
  bm = 0;
  if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); bm = 4; }
  if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); bm = 8; }
  return maxValue;
}
inline double bivector::largestCoordinate() const {
  double maxValue = ::fabs(m_c[0]);
  if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); }
  if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); }
  if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); }
  if (::fabs(m_c[4]) > maxValue) { maxValue = ::fabs(m_c[4]); }
  if (::fabs(m_c[5]) > maxValue) { maxValue = ::fabs(m_c[5]); }
  return maxValue;
}
inline double bivector::largestBasisBlade(unsigned int &bm) const {
  double maxValue = ::fabs(m_c[0]);
  bm = 0;
  if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); bm = 5; }
  if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); bm = 9; }
  if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); bm = 6; }
  if (::fabs(m_c[4]) > maxValue) { maxValue = ::fabs(m_c[4]); bm = 10; }
  if (::fabs(m_c[5]) > maxValue) { maxValue = ::fabs(m_c[5]); bm = 12; }
  return maxValue;
}
inline double bivector3::largestCoordinate() const {
  double maxValue = ::fabs(m_c[0]);
  if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); }
  if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); }
  return maxValue;
}
inline double bivector3::largestBasisBlade(unsigned int &bm) const {
  double maxValue = ::fabs(m_c[0]);
  bm = 0;
  if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); bm = 10; }
  if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); bm = 12; }
  return maxValue;
}
inline double pseudovector::largestCoordinate() const {
  double maxValue = ::fabs(m_c[0]);
  if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); }
  if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); }
  if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); }
  return maxValue;
}
inline double pseudovector::largestBasisBlade(unsigned int &bm) const {
  double maxValue = ::fabs(m_c[0]);
  bm = 0;
  if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); bm = 11; }
  if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); bm = 13; }
  if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); bm = 14; }
  return maxValue;
}
inline double spinor::largestCoordinate() const {
  double maxValue = ::fabs(m_c[0]);
  if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); }
  if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); }
  if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); }
  if (::fabs(m_c[4]) > maxValue) { maxValue = ::fabs(m_c[4]); }
  if (::fabs(m_c[5]) > maxValue) { maxValue = ::fabs(m_c[5]); }
  if (::fabs(m_c[6]) > maxValue) { maxValue = ::fabs(m_c[6]); }
  if (::fabs(m_c[7]) > maxValue) { maxValue = ::fabs(m_c[7]); }
  return maxValue;
}
inline double spinor::largestBasisBlade(unsigned int &bm) const {
  double maxValue = ::fabs(m_c[0]);
  bm = 0;
  if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); bm = 3; }
  if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); bm = 5; }
  if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); bm = 9; }
  if (::fabs(m_c[4]) > maxValue) { maxValue = ::fabs(m_c[4]); bm = 6; }
  if (::fabs(m_c[5]) > maxValue) { maxValue = ::fabs(m_c[5]); bm = 10; }
  if (::fabs(m_c[6]) > maxValue) { maxValue = ::fabs(m_c[6]); bm = 12; }
  if (::fabs(m_c[7]) > maxValue) { maxValue = ::fabs(m_c[7]); bm = 15; }
  return maxValue;
}
inline double spinor3::largestCoordinate() const {
  double maxValue = ::fabs(m_c[0]);
  if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); }
  if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); }
  if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); }
  return maxValue;
}
inline double spinor3::largestBasisBlade(unsigned int &bm) const {
  double maxValue = ::fabs(m_c[0]);
  bm = 0;
  if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); bm = 6; }
  if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); bm = 10; }
  if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); bm = 12; }
  return maxValue;
}

inline double _double(const gamma_0_t &x) {
  return 0.0;
}
inline double _double(const gamma_1_t &x) {
  return 0.0;
}
inline double _double(const gamma_2_t &x) {
  return 0.0;
}
inline double _double(const gamma_3_t &x) {
  return 0.0;
}
inline double _double(const I_t &x) {
  return 0.0;
}
inline double _double(const I3_t &x) {
  return 0.0;
}
inline double _double(const mv3 &x) {
  return x.m_c[0];
}
inline double _double(const vector &x) {
  return 0.0;
}
inline double _double(const vector3 &x) {
  return 0.0;
}
inline double _double(const bivector &x) {
  return 0.0;
}
inline double _double(const bivector3 &x) {
  return 0.0;
}
inline double _double(const pseudovector &x) {
  return 0.0;
}
inline double _double(const spinor &x) {
  return x.m_c[0];
}
inline double _double(const spinor3 &x) {
  return x.m_c[0];
}
inline vector3 _vector3(const vector &a)
{
  return vector3(vector3::coord_gamma_1_gamma_2_gamma_3,
      a.m_c[1], // gamma_1
      a.m_c[2], // gamma_2
      a.m_c[3] // gamma_3
    );

}
inline bivector3 _bivector3(const bivector &a)
{
  return bivector3(bivector3::coord_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a.m_c[3], // gamma_1_gamma_2
      a.m_c[4], // gamma_1_gamma_3
      a.m_c[5] // gamma_2_gamma_3
    );

}
inline spinor3 _spinor3(const spinor &a)
{
  return spinor3(spinor3::coord_scalar_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a.m_c[0], // scalar
      a.m_c[4], // gamma_1_gamma_2
      a.m_c[5], // gamma_1_gamma_3
      a.m_c[6] // gamma_2_gamma_3
    );

}
inline double extractGrade0(const mv3 &a)
{
  return a.m_c[0];
}
inline double extractGrade0(const vector &a)
{
  return 0.0;
}
inline double extractGrade0(const vector3 &a)
{
  return 0.0;
}
inline double extractGrade0(const bivector &a)
{
  return 0.0;
}
inline double extractGrade0(const bivector3 &a)
{
  return 0.0;
}
inline double extractGrade0(const pseudovector &a)
{
  return 0.0;
}
inline double extractGrade0(const spinor &a)
{
  return a.m_c[0];
}
inline double extractGrade0(const spinor3 &a)
{
  return a.m_c[0];
}
inline vector3 extractGrade1(const mv3 &a)
{
  return vector3(vector3::coord_gamma_1_gamma_2_gamma_3,
      a.m_c[1], // gamma_1
      a.m_c[2], // gamma_2
      a.m_c[3] // gamma_3
    );
}
inline vector extractGrade1(const vector &a)
{
  return vector(vector::coord_gamma_0_gamma_1_gamma_2_gamma_3,
      a.m_c[0], // gamma_0
      a.m_c[1], // gamma_1
      a.m_c[2], // gamma_2
      a.m_c[3] // gamma_3
    );
}
inline vector3 extractGrade1(const vector3 &a)
{
  return vector3(vector3::coord_gamma_1_gamma_2_gamma_3,
      a.m_c[0], // gamma_1
      a.m_c[1], // gamma_2
      a.m_c[2] // gamma_3
    );
}
inline double extractGrade1(const bivector &a)
{
  return 0.0;
}
inline double extractGrade1(const bivector3 &a)
{
  return 0.0;
}
inline double extractGrade1(const pseudovector &a)
{
  return 0.0;
}
inline double extractGrade1(const spinor &a)
{
  return 0.0;
}
inline double extractGrade1(const spinor3 &a)
{
  return 0.0;
}
inline bivector3 extractGrade2(const mv3 &a)
{
  return bivector3(bivector3::coord_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a.m_c[4], // gamma_1_gamma_2
      a.m_c[5], // gamma_1_gamma_3
      a.m_c[6] // gamma_2_gamma_3
    );
}
inline double extractGrade2(const vector &a)
{
  return 0.0;
}
inline double extractGrade2(const vector3 &a)
{
  return 0.0;
}
inline bivector extractGrade2(const bivector &a)
{
  return bivector(bivector::coord_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a.m_c[0], // gamma_0_gamma_1
      a.m_c[1], // gamma_0_gamma_2
      a.m_c[2], // gamma_0_gamma_3
      a.m_c[3], // gamma_1_gamma_2
      a.m_c[4], // gamma_1_gamma_3
      a.m_c[5] // gamma_2_gamma_3
    );
}
inline bivector3 extractGrade2(const bivector3 &a)
{
  return bivector3(bivector3::coord_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a.m_c[0], // gamma_1_gamma_2
      a.m_c[1], // gamma_1_gamma_3
      a.m_c[2] // gamma_2_gamma_3
    );
}
inline double extractGrade2(const pseudovector &a)
{
  return 0.0;
}
inline bivector extractGrade2(const spinor &a)
{
  return bivector(bivector::coord_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a.m_c[1], // gamma_0_gamma_1
      a.m_c[2], // gamma_0_gamma_2
      a.m_c[3], // gamma_0_gamma_3
      a.m_c[4], // gamma_1_gamma_2
      a.m_c[5], // gamma_1_gamma_3
      a.m_c[6] // gamma_2_gamma_3
    );
}
inline bivector3 extractGrade2(const spinor3 &a)
{
  return bivector3(bivector3::coord_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a.m_c[1], // gamma_1_gamma_2
      a.m_c[2], // gamma_1_gamma_3
      a.m_c[3] // gamma_2_gamma_3
    );
}
inline pseudovector extractGrade3(const mv3 &a)
{
  return pseudovector(pseudovector::coord_gamma_0gamma_1gamma_2_gamma_0gamma_1gamma_3_gamma_0gamma_2gamma_3_gamma_1gamma_2gamma_3,
      0.0, // gamma_0_gamma_1_gamma_2
      0.0, // gamma_0_gamma_1_gamma_3
      0.0, // gamma_0_gamma_2_gamma_3
      a.m_c[7] // gamma_1_gamma_2_gamma_3
    );
}
inline double extractGrade3(const vector &a)
{
  return 0.0;
}
inline double extractGrade3(const vector3 &a)
{
  return 0.0;
}
inline double extractGrade3(const bivector &a)
{
  return 0.0;
}
inline double extractGrade3(const bivector3 &a)
{
  return 0.0;
}
inline pseudovector extractGrade3(const pseudovector &a)
{
  return pseudovector(pseudovector::coord_gamma_0gamma_1gamma_2_gamma_0gamma_1gamma_3_gamma_0gamma_2gamma_3_gamma_1gamma_2gamma_3,
      a.m_c[0], // gamma_0_gamma_1_gamma_2
      a.m_c[1], // gamma_0_gamma_1_gamma_3
      a.m_c[2], // gamma_0_gamma_2_gamma_3
      a.m_c[3] // gamma_1_gamma_2_gamma_3
    );
}
inline double extractGrade3(const spinor &a)
{
  return 0.0;
}
inline double extractGrade3(const spinor3 &a)
{
  return 0.0;
}
inline double extractGrade4(const mv3 &a)
{
  return 0.0;
}
inline double extractGrade4(const vector &a)
{
  return 0.0;
}
inline double extractGrade4(const vector3 &a)
{
  return 0.0;
}
inline double extractGrade4(const bivector &a)
{
  return 0.0;
}
inline double extractGrade4(const bivector3 &a)
{
  return 0.0;
}
inline double extractGrade4(const pseudovector &a)
{
  return 0.0;
}
inline spinor extractGrade4(const spinor &a)
{
  return spinor(spinor::coord_scalar_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_0gamma_1gamma_2gamma_3,
      0.0, // scalar
      0.0, // gamma_0_gamma_1
      0.0, // gamma_0_gamma_2
      0.0, // gamma_0_gamma_3
      0.0, // gamma_1_gamma_2
      0.0, // gamma_1_gamma_3
      0.0, // gamma_2_gamma_3
      a.m_c[7] // gamma_0_gamma_1_gamma_2_gamma_3
    );
}
inline double extractGrade4(const spinor3 &a)
{
  return 0.0;
}
inline mv3 add(const mv3 &a, const mv3 &b)
{
  return mv3(mv3::coord_scalar_gamma_1_gamma_2_gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_1gamma_2gamma_3,
      (a.m_c[0]+b.m_c[0]), // scalar
      (a.m_c[1]+b.m_c[1]), // gamma_1
      (a.m_c[2]+b.m_c[2]), // gamma_2
      (a.m_c[3]+b.m_c[3]), // gamma_3
      (a.m_c[4]+b.m_c[4]), // gamma_1_gamma_2
      (a.m_c[5]+b.m_c[5]), // gamma_1_gamma_3
      (a.m_c[6]+b.m_c[6]), // gamma_2_gamma_3
      (a.m_c[7]+b.m_c[7]) // gamma_1_gamma_2_gamma_3
    );

}
inline vector add(const vector &a, const vector &b)
{
  return vector(vector::coord_gamma_0_gamma_1_gamma_2_gamma_3,
      (a.m_c[0]+b.m_c[0]), // gamma_0
      (a.m_c[1]+b.m_c[1]), // gamma_1
      (a.m_c[2]+b.m_c[2]), // gamma_2
      (a.m_c[3]+b.m_c[3]) // gamma_3
    );

}
inline vector3 add(const vector3 &a, const vector3 &b)
{
  return vector3(vector3::coord_gamma_1_gamma_2_gamma_3,
      (a.m_c[0]+b.m_c[0]), // gamma_1
      (a.m_c[1]+b.m_c[1]), // gamma_2
      (a.m_c[2]+b.m_c[2]) // gamma_3
    );

}
inline bivector add(const bivector &a, const bivector &b)
{
  return bivector(bivector::coord_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      (a.m_c[0]+b.m_c[0]), // gamma_0_gamma_1
      (a.m_c[1]+b.m_c[1]), // gamma_0_gamma_2
      (a.m_c[2]+b.m_c[2]), // gamma_0_gamma_3
      (a.m_c[3]+b.m_c[3]), // gamma_1_gamma_2
      (a.m_c[4]+b.m_c[4]), // gamma_1_gamma_3
      (a.m_c[5]+b.m_c[5]) // gamma_2_gamma_3
    );

}
inline bivector3 add(const bivector3 &a, const bivector3 &b)
{
  return bivector3(bivector3::coord_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      (a.m_c[0]+b.m_c[0]), // gamma_1_gamma_2
      (a.m_c[1]+b.m_c[1]), // gamma_1_gamma_3
      (a.m_c[2]+b.m_c[2]) // gamma_2_gamma_3
    );

}
inline pseudovector add(const pseudovector &a, const pseudovector &b)
{
  return pseudovector(pseudovector::coord_gamma_0gamma_1gamma_2_gamma_0gamma_1gamma_3_gamma_0gamma_2gamma_3_gamma_1gamma_2gamma_3,
      (a.m_c[0]+b.m_c[0]), // gamma_0_gamma_1_gamma_2
      (a.m_c[1]+b.m_c[1]), // gamma_0_gamma_1_gamma_3
      (a.m_c[2]+b.m_c[2]), // gamma_0_gamma_2_gamma_3
      (a.m_c[3]+b.m_c[3]) // gamma_1_gamma_2_gamma_3
    );

}
inline spinor add(const spinor &a, const spinor &b)
{
  return spinor(spinor::coord_scalar_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_0gamma_1gamma_2gamma_3,
      (a.m_c[0]+b.m_c[0]), // scalar
      (a.m_c[1]+b.m_c[1]), // gamma_0_gamma_1
      (a.m_c[2]+b.m_c[2]), // gamma_0_gamma_2
      (a.m_c[3]+b.m_c[3]), // gamma_0_gamma_3
      (a.m_c[4]+b.m_c[4]), // gamma_1_gamma_2
      (a.m_c[5]+b.m_c[5]), // gamma_1_gamma_3
      (a.m_c[6]+b.m_c[6]), // gamma_2_gamma_3
      (a.m_c[7]+b.m_c[7]) // gamma_0_gamma_1_gamma_2_gamma_3
    );

}
inline spinor3 add(const spinor3 &a, const spinor3 &b)
{
  return spinor3(spinor3::coord_scalar_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      (a.m_c[0]+b.m_c[0]), // scalar
      (a.m_c[1]+b.m_c[1]), // gamma_1_gamma_2
      (a.m_c[2]+b.m_c[2]), // gamma_1_gamma_3
      (a.m_c[3]+b.m_c[3]) // gamma_2_gamma_3
    );

}
inline mv3 subtract(const mv3 &a, const mv3 &b)
{
  return mv3(mv3::coord_scalar_gamma_1_gamma_2_gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_1gamma_2gamma_3,
      (a.m_c[0]-b.m_c[0]), // scalar
      (a.m_c[1]-b.m_c[1]), // gamma_1
      (a.m_c[2]-b.m_c[2]), // gamma_2
      (a.m_c[3]-b.m_c[3]), // gamma_3
      (a.m_c[4]-b.m_c[4]), // gamma_1_gamma_2
      (a.m_c[5]-b.m_c[5]), // gamma_1_gamma_3
      (a.m_c[6]-b.m_c[6]), // gamma_2_gamma_3
      (a.m_c[7]-b.m_c[7]) // gamma_1_gamma_2_gamma_3
    );

}
inline vector subtract(const vector &a, const vector &b)
{
  return vector(vector::coord_gamma_0_gamma_1_gamma_2_gamma_3,
      (a.m_c[0]-b.m_c[0]), // gamma_0
      (a.m_c[1]-b.m_c[1]), // gamma_1
      (a.m_c[2]-b.m_c[2]), // gamma_2
      (a.m_c[3]-b.m_c[3]) // gamma_3
    );

}
inline vector3 subtract(const vector3 &a, const vector3 &b)
{
  return vector3(vector3::coord_gamma_1_gamma_2_gamma_3,
      (a.m_c[0]-b.m_c[0]), // gamma_1
      (a.m_c[1]-b.m_c[1]), // gamma_2
      (a.m_c[2]-b.m_c[2]) // gamma_3
    );

}
inline bivector subtract(const bivector &a, const bivector &b)
{
  return bivector(bivector::coord_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      (a.m_c[0]-b.m_c[0]), // gamma_0_gamma_1
      (a.m_c[1]-b.m_c[1]), // gamma_0_gamma_2
      (a.m_c[2]-b.m_c[2]), // gamma_0_gamma_3
      (a.m_c[3]-b.m_c[3]), // gamma_1_gamma_2
      (a.m_c[4]-b.m_c[4]), // gamma_1_gamma_3
      (a.m_c[5]-b.m_c[5]) // gamma_2_gamma_3
    );

}
inline bivector3 subtract(const bivector3 &a, const bivector3 &b)
{
  return bivector3(bivector3::coord_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      (a.m_c[0]-b.m_c[0]), // gamma_1_gamma_2
      (a.m_c[1]-b.m_c[1]), // gamma_1_gamma_3
      (a.m_c[2]-b.m_c[2]) // gamma_2_gamma_3
    );

}
inline pseudovector subtract(const pseudovector &a, const pseudovector &b)
{
  return pseudovector(pseudovector::coord_gamma_0gamma_1gamma_2_gamma_0gamma_1gamma_3_gamma_0gamma_2gamma_3_gamma_1gamma_2gamma_3,
      (a.m_c[0]-b.m_c[0]), // gamma_0_gamma_1_gamma_2
      (a.m_c[1]-b.m_c[1]), // gamma_0_gamma_1_gamma_3
      (a.m_c[2]-b.m_c[2]), // gamma_0_gamma_2_gamma_3
      (a.m_c[3]-b.m_c[3]) // gamma_1_gamma_2_gamma_3
    );

}
inline spinor subtract(const spinor &a, const spinor &b)
{
  return spinor(spinor::coord_scalar_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_0gamma_1gamma_2gamma_3,
      (a.m_c[0]-b.m_c[0]), // scalar
      (a.m_c[1]-b.m_c[1]), // gamma_0_gamma_1
      (a.m_c[2]-b.m_c[2]), // gamma_0_gamma_2
      (a.m_c[3]-b.m_c[3]), // gamma_0_gamma_3
      (a.m_c[4]-b.m_c[4]), // gamma_1_gamma_2
      (a.m_c[5]-b.m_c[5]), // gamma_1_gamma_3
      (a.m_c[6]-b.m_c[6]), // gamma_2_gamma_3
      (a.m_c[7]-b.m_c[7]) // gamma_0_gamma_1_gamma_2_gamma_3
    );

}
inline spinor3 subtract(const spinor3 &a, const spinor3 &b)
{
  return spinor3(spinor3::coord_scalar_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      (a.m_c[0]-b.m_c[0]), // scalar
      (a.m_c[1]-b.m_c[1]), // gamma_1_gamma_2
      (a.m_c[2]-b.m_c[2]), // gamma_1_gamma_3
      (a.m_c[3]-b.m_c[3]) // gamma_2_gamma_3
    );

}
inline mv3 gp(const double a, const mv3 &b)
{
  return mv3(mv3::coord_scalar_gamma_1_gamma_2_gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_1gamma_2gamma_3,
      a*b.m_c[0], // scalar
      a*b.m_c[1], // gamma_1
      a*b.m_c[2], // gamma_2
      a*b.m_c[3], // gamma_3
      a*b.m_c[4], // gamma_1_gamma_2
      a*b.m_c[5], // gamma_1_gamma_3
      a*b.m_c[6], // gamma_2_gamma_3
      a*b.m_c[7] // gamma_1_gamma_2_gamma_3
    );

}
inline vector gp(const double a, const vector &b)
{
  return vector(vector::coord_gamma_0_gamma_1_gamma_2_gamma_3,
      a*b.m_c[0], // gamma_0
      a*b.m_c[1], // gamma_1
      a*b.m_c[2], // gamma_2
      a*b.m_c[3] // gamma_3
    );

}
inline vector3 gp(const double a, const vector3 &b)
{
  return vector3(vector3::coord_gamma_1_gamma_2_gamma_3,
      a*b.m_c[0], // gamma_1
      a*b.m_c[1], // gamma_2
      a*b.m_c[2] // gamma_3
    );

}
inline bivector gp(const double a, const bivector &b)
{
  return bivector(bivector::coord_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a*b.m_c[0], // gamma_0_gamma_1
      a*b.m_c[1], // gamma_0_gamma_2
      a*b.m_c[2], // gamma_0_gamma_3
      a*b.m_c[3], // gamma_1_gamma_2
      a*b.m_c[4], // gamma_1_gamma_3
      a*b.m_c[5] // gamma_2_gamma_3
    );

}
inline bivector3 gp(const double a, const bivector3 &b)
{
  return bivector3(bivector3::coord_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a*b.m_c[0], // gamma_1_gamma_2
      a*b.m_c[1], // gamma_1_gamma_3
      a*b.m_c[2] // gamma_2_gamma_3
    );

}
inline pseudovector gp(const double a, const pseudovector &b)
{
  return pseudovector(pseudovector::coord_gamma_0gamma_1gamma_2_gamma_0gamma_1gamma_3_gamma_0gamma_2gamma_3_gamma_1gamma_2gamma_3,
      a*b.m_c[0], // gamma_0_gamma_1_gamma_2
      a*b.m_c[1], // gamma_0_gamma_1_gamma_3
      a*b.m_c[2], // gamma_0_gamma_2_gamma_3
      a*b.m_c[3] // gamma_1_gamma_2_gamma_3
    );

}
inline spinor gp(const double a, const spinor &b)
{
  return spinor(spinor::coord_scalar_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_0gamma_1gamma_2gamma_3,
      a*b.m_c[0], // scalar
      a*b.m_c[1], // gamma_0_gamma_1
      a*b.m_c[2], // gamma_0_gamma_2
      a*b.m_c[3], // gamma_0_gamma_3
      a*b.m_c[4], // gamma_1_gamma_2
      a*b.m_c[5], // gamma_1_gamma_3
      a*b.m_c[6], // gamma_2_gamma_3
      a*b.m_c[7] // gamma_0_gamma_1_gamma_2_gamma_3
    );

}
inline spinor3 gp(const double a, const spinor3 &b)
{
  return spinor3(spinor3::coord_scalar_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a*b.m_c[0], // scalar
      a*b.m_c[1], // gamma_1_gamma_2
      a*b.m_c[2], // gamma_1_gamma_3
      a*b.m_c[3] // gamma_2_gamma_3
    );

}
inline mv3 gp(const mv3 &a, const double b)
{
  return mv3(mv3::coord_scalar_gamma_1_gamma_2_gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_1gamma_2gamma_3,
      a.m_c[0]*b, // scalar
      a.m_c[1]*b, // gamma_1
      a.m_c[2]*b, // gamma_2
      a.m_c[3]*b, // gamma_3
      a.m_c[4]*b, // gamma_1_gamma_2
      a.m_c[5]*b, // gamma_1_gamma_3
      a.m_c[6]*b, // gamma_2_gamma_3
      a.m_c[7]*b // gamma_1_gamma_2_gamma_3
    );

}
inline vector gp(const vector &a, const double b)
{
  return vector(vector::coord_gamma_0_gamma_1_gamma_2_gamma_3,
      a.m_c[0]*b, // gamma_0
      a.m_c[1]*b, // gamma_1
      a.m_c[2]*b, // gamma_2
      a.m_c[3]*b // gamma_3
    );

}
inline vector3 gp(const vector3 &a, const double b)
{
  return vector3(vector3::coord_gamma_1_gamma_2_gamma_3,
      a.m_c[0]*b, // gamma_1
      a.m_c[1]*b, // gamma_2
      a.m_c[2]*b // gamma_3
    );

}
inline bivector gp(const bivector &a, const double b)
{
  return bivector(bivector::coord_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a.m_c[0]*b, // gamma_0_gamma_1
      a.m_c[1]*b, // gamma_0_gamma_2
      a.m_c[2]*b, // gamma_0_gamma_3
      a.m_c[3]*b, // gamma_1_gamma_2
      a.m_c[4]*b, // gamma_1_gamma_3
      a.m_c[5]*b // gamma_2_gamma_3
    );

}
inline bivector3 gp(const bivector3 &a, const double b)
{
  return bivector3(bivector3::coord_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a.m_c[0]*b, // gamma_1_gamma_2
      a.m_c[1]*b, // gamma_1_gamma_3
      a.m_c[2]*b // gamma_2_gamma_3
    );

}
inline pseudovector gp(const pseudovector &a, const double b)
{
  return pseudovector(pseudovector::coord_gamma_0gamma_1gamma_2_gamma_0gamma_1gamma_3_gamma_0gamma_2gamma_3_gamma_1gamma_2gamma_3,
      a.m_c[0]*b, // gamma_0_gamma_1_gamma_2
      a.m_c[1]*b, // gamma_0_gamma_1_gamma_3
      a.m_c[2]*b, // gamma_0_gamma_2_gamma_3
      a.m_c[3]*b // gamma_1_gamma_2_gamma_3
    );

}
inline spinor gp(const spinor &a, const double b)
{
  return spinor(spinor::coord_scalar_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_0gamma_1gamma_2gamma_3,
      a.m_c[0]*b, // scalar
      a.m_c[1]*b, // gamma_0_gamma_1
      a.m_c[2]*b, // gamma_0_gamma_2
      a.m_c[3]*b, // gamma_0_gamma_3
      a.m_c[4]*b, // gamma_1_gamma_2
      a.m_c[5]*b, // gamma_1_gamma_3
      a.m_c[6]*b, // gamma_2_gamma_3
      a.m_c[7]*b // gamma_0_gamma_1_gamma_2_gamma_3
    );

}
inline spinor3 gp(const spinor3 &a, const double b)
{
  return spinor3(spinor3::coord_scalar_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a.m_c[0]*b, // scalar
      a.m_c[1]*b, // gamma_1_gamma_2
      a.m_c[2]*b, // gamma_1_gamma_3
      a.m_c[3]*b // gamma_2_gamma_3
    );

}
inline mv3 div(const mv3 &a, const double b)
{
  return mv3(mv3::coord_scalar_gamma_1_gamma_2_gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_1gamma_2gamma_3,
      a.m_c[0]/((b)), // scalar
      a.m_c[1]/((b)), // gamma_1
      a.m_c[2]/((b)), // gamma_2
      a.m_c[3]/((b)), // gamma_3
      a.m_c[4]/((b)), // gamma_1_gamma_2
      a.m_c[5]/((b)), // gamma_1_gamma_3
      a.m_c[6]/((b)), // gamma_2_gamma_3
      a.m_c[7]/((b)) // gamma_1_gamma_2_gamma_3
    );
}
inline vector div(const vector &a, const double b)
{
  return vector(vector::coord_gamma_0_gamma_1_gamma_2_gamma_3,
      a.m_c[0]/((b)), // gamma_0
      a.m_c[1]/((b)), // gamma_1
      a.m_c[2]/((b)), // gamma_2
      a.m_c[3]/((b)) // gamma_3
    );
}
inline vector3 div(const vector3 &a, const double b)
{
  return vector3(vector3::coord_gamma_1_gamma_2_gamma_3,
      a.m_c[0]/((b)), // gamma_1
      a.m_c[1]/((b)), // gamma_2
      a.m_c[2]/((b)) // gamma_3
    );
}
inline bivector div(const bivector &a, const double b)
{
  return bivector(bivector::coord_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a.m_c[0]/((b)), // gamma_0_gamma_1
      a.m_c[1]/((b)), // gamma_0_gamma_2
      a.m_c[2]/((b)), // gamma_0_gamma_3
      a.m_c[3]/((b)), // gamma_1_gamma_2
      a.m_c[4]/((b)), // gamma_1_gamma_3
      a.m_c[5]/((b)) // gamma_2_gamma_3
    );
}
inline bivector3 div(const bivector3 &a, const double b)
{
  return bivector3(bivector3::coord_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a.m_c[0]/((b)), // gamma_1_gamma_2
      a.m_c[1]/((b)), // gamma_1_gamma_3
      a.m_c[2]/((b)) // gamma_2_gamma_3
    );
}
inline pseudovector div(const pseudovector &a, const double b)
{
  return pseudovector(pseudovector::coord_gamma_0gamma_1gamma_2_gamma_0gamma_1gamma_3_gamma_0gamma_2gamma_3_gamma_1gamma_2gamma_3,
      a.m_c[0]/((b)), // gamma_0_gamma_1_gamma_2
      a.m_c[1]/((b)), // gamma_0_gamma_1_gamma_3
      a.m_c[2]/((b)), // gamma_0_gamma_2_gamma_3
      a.m_c[3]/((b)) // gamma_1_gamma_2_gamma_3
    );
}
inline spinor div(const spinor &a, const double b)
{
  return spinor(spinor::coord_scalar_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_0gamma_1gamma_2gamma_3,
      a.m_c[0]/((b)), // scalar
      a.m_c[1]/((b)), // gamma_0_gamma_1
      a.m_c[2]/((b)), // gamma_0_gamma_2
      a.m_c[3]/((b)), // gamma_0_gamma_3
      a.m_c[4]/((b)), // gamma_1_gamma_2
      a.m_c[5]/((b)), // gamma_1_gamma_3
      a.m_c[6]/((b)), // gamma_2_gamma_3
      a.m_c[7]/((b)) // gamma_0_gamma_1_gamma_2_gamma_3
    );
}
inline spinor3 div(const spinor3 &a, const double b)
{
  return spinor3(spinor3::coord_scalar_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a.m_c[0]/((b)), // scalar
      a.m_c[1]/((b)), // gamma_1_gamma_2
      a.m_c[2]/((b)), // gamma_1_gamma_3
      a.m_c[3]/((b)) // gamma_2_gamma_3
    );
}
inline spinor gp(const spinor &a, const spinor &b)
{
  return spinor(spinor::coord_scalar_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_0gamma_1gamma_2gamma_3,
      (a.m_c[0]*b.m_c[0]+a.m_c[1]*b.m_c[1]+a.m_c[2]*b.m_c[2]+a.m_c[3]*b.m_c[3]-a.m_c[4]*b.m_c[4]-a.m_c[5]*b.m_c[5]-a.m_c[6]*b.m_c[6]-a.m_c[7]*b.m_c[7]), // scalar
      (a.m_c[0]*b.m_c[1]+a.m_c[1]*b.m_c[0]-a.m_c[2]*b.m_c[4]-a.m_c[3]*b.m_c[5]+a.m_c[4]*b.m_c[2]+a.m_c[5]*b.m_c[3]-a.m_c[6]*b.m_c[7]-a.m_c[7]*b.m_c[6]), // gamma_0_gamma_1
      (a.m_c[0]*b.m_c[2]+a.m_c[1]*b.m_c[4]+a.m_c[2]*b.m_c[0]-a.m_c[3]*b.m_c[6]-a.m_c[4]*b.m_c[1]+a.m_c[5]*b.m_c[7]+a.m_c[6]*b.m_c[3]+a.m_c[7]*b.m_c[5]), // gamma_0_gamma_2
      (a.m_c[0]*b.m_c[3]+a.m_c[1]*b.m_c[5]+a.m_c[2]*b.m_c[6]+a.m_c[3]*b.m_c[0]-a.m_c[4]*b.m_c[7]-a.m_c[5]*b.m_c[1]-a.m_c[6]*b.m_c[2]-a.m_c[7]*b.m_c[4]), // gamma_0_gamma_3
      (a.m_c[0]*b.m_c[4]+a.m_c[1]*b.m_c[2]-a.m_c[2]*b.m_c[1]+a.m_c[3]*b.m_c[7]+a.m_c[4]*b.m_c[0]-a.m_c[5]*b.m_c[6]+a.m_c[6]*b.m_c[5]+a.m_c[7]*b.m_c[3]), // gamma_1_gamma_2
      (a.m_c[0]*b.m_c[5]+a.m_c[1]*b.m_c[3]-a.m_c[2]*b.m_c[7]-a.m_c[3]*b.m_c[1]+a.m_c[4]*b.m_c[6]+a.m_c[5]*b.m_c[0]-a.m_c[6]*b.m_c[4]-a.m_c[7]*b.m_c[2]), // gamma_1_gamma_3
      (a.m_c[0]*b.m_c[6]+a.m_c[1]*b.m_c[7]+a.m_c[2]*b.m_c[3]-a.m_c[3]*b.m_c[2]-a.m_c[4]*b.m_c[5]+a.m_c[5]*b.m_c[4]+a.m_c[6]*b.m_c[0]+a.m_c[7]*b.m_c[1]), // gamma_2_gamma_3
      (a.m_c[0]*b.m_c[7]+a.m_c[1]*b.m_c[6]-a.m_c[2]*b.m_c[5]+a.m_c[3]*b.m_c[4]+a.m_c[4]*b.m_c[3]-a.m_c[5]*b.m_c[2]+a.m_c[6]*b.m_c[1]+a.m_c[7]*b.m_c[0]) // gamma_0_gamma_1_gamma_2_gamma_3
    );

}
inline spinor3 gp(const spinor3 &a, const spinor3 &b)
{
  return spinor3(spinor3::coord_scalar_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      (a.m_c[0]*b.m_c[0]-a.m_c[1]*b.m_c[1]-a.m_c[2]*b.m_c[2]-a.m_c[3]*b.m_c[3]), // scalar
      (a.m_c[0]*b.m_c[1]+a.m_c[1]*b.m_c[0]-a.m_c[2]*b.m_c[3]+a.m_c[3]*b.m_c[2]), // gamma_1_gamma_2
      (a.m_c[0]*b.m_c[2]+a.m_c[1]*b.m_c[3]+a.m_c[2]*b.m_c[0]-a.m_c[3]*b.m_c[1]), // gamma_1_gamma_3
      (a.m_c[0]*b.m_c[3]-a.m_c[1]*b.m_c[2]+a.m_c[2]*b.m_c[1]+a.m_c[3]*b.m_c[0]) // gamma_2_gamma_3
    );

}
inline double sp(const mv3 &a, const mv3 &b)
{
  return (a.m_c[0]*b.m_c[0]+a.m_c[1]*b.m_c[1]+a.m_c[2]*b.m_c[2]+a.m_c[3]*b.m_c[3]-a.m_c[4]*b.m_c[4]-a.m_c[5]*b.m_c[5]-a.m_c[6]*b.m_c[6]-a.m_c[7]*b.m_c[7]);

}
inline double sp(const vector &a, const vector &b)
{
  return (-a.m_c[0]*b.m_c[0]+a.m_c[1]*b.m_c[1]+a.m_c[2]*b.m_c[2]+a.m_c[3]*b.m_c[3]);

}
inline double sp(const vector3 &a, const vector3 &b)
{
  return (a.m_c[0]*b.m_c[0]+a.m_c[1]*b.m_c[1]+a.m_c[2]*b.m_c[2]);

}
inline double sp(const bivector &a, const bivector &b)
{
  return (a.m_c[0]*b.m_c[0]+a.m_c[1]*b.m_c[1]+a.m_c[2]*b.m_c[2]-a.m_c[3]*b.m_c[3]-a.m_c[4]*b.m_c[4]-a.m_c[5]*b.m_c[5]);

}
inline double sp(const bivector3 &a, const bivector3 &b)
{
  return (-a.m_c[0]*b.m_c[0]-a.m_c[1]*b.m_c[1]-a.m_c[2]*b.m_c[2]);

}
inline double sp(const pseudovector &a, const pseudovector &b)
{
  return (a.m_c[0]*b.m_c[0]+a.m_c[1]*b.m_c[1]+a.m_c[2]*b.m_c[2]-a.m_c[3]*b.m_c[3]);

}
inline double sp(const spinor &a, const spinor &b)
{
  return (a.m_c[0]*b.m_c[0]+a.m_c[1]*b.m_c[1]+a.m_c[2]*b.m_c[2]+a.m_c[3]*b.m_c[3]-a.m_c[4]*b.m_c[4]-a.m_c[5]*b.m_c[5]-a.m_c[6]*b.m_c[6]-a.m_c[7]*b.m_c[7]);

}
inline double sp(const spinor3 &a, const spinor3 &b)
{
  return (a.m_c[0]*b.m_c[0]-a.m_c[1]*b.m_c[1]-a.m_c[2]*b.m_c[2]-a.m_c[3]*b.m_c[3]);

}
inline bivector op(const vector &a, const vector &b)
{
  return bivector(bivector::coord_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      (a.m_c[0]*b.m_c[1]-a.m_c[1]*b.m_c[0]), // gamma_0_gamma_1
      (a.m_c[0]*b.m_c[2]-a.m_c[2]*b.m_c[0]), // gamma_0_gamma_2
      (a.m_c[0]*b.m_c[3]-a.m_c[3]*b.m_c[0]), // gamma_0_gamma_3
      (a.m_c[1]*b.m_c[2]-a.m_c[2]*b.m_c[1]), // gamma_1_gamma_2
      (a.m_c[1]*b.m_c[3]-a.m_c[3]*b.m_c[1]), // gamma_1_gamma_3
      (a.m_c[2]*b.m_c[3]-a.m_c[3]*b.m_c[2]) // gamma_2_gamma_3
    );

}
inline bivector3 op(const vector3 &a, const vector3 &b)
{
  return bivector3(bivector3::coord_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      (a.m_c[0]*b.m_c[1]-a.m_c[1]*b.m_c[0]), // gamma_1_gamma_2
      (a.m_c[0]*b.m_c[2]-a.m_c[2]*b.m_c[0]), // gamma_1_gamma_3
      (a.m_c[1]*b.m_c[2]-a.m_c[2]*b.m_c[1]) // gamma_2_gamma_3
    );

}
inline spinor op(const bivector &a, const bivector &b)
{
  return spinor(spinor::coord_scalar_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_0gamma_1gamma_2gamma_3,
      0.0, // scalar
      0.0, // gamma_0_gamma_1
      0.0, // gamma_0_gamma_2
      0.0, // gamma_0_gamma_3
      0.0, // gamma_1_gamma_2
      0.0, // gamma_1_gamma_3
      0.0, // gamma_2_gamma_3
      (a.m_c[0]*b.m_c[5]-a.m_c[1]*b.m_c[4]+a.m_c[2]*b.m_c[3]+a.m_c[3]*b.m_c[2]-a.m_c[4]*b.m_c[1]+a.m_c[5]*b.m_c[0]) // gamma_0_gamma_1_gamma_2_gamma_3
    );

}
inline double op(const bivector3 &a, const bivector3 &b)
{
  return 0.0;

}
inline pseudovector dual(const vector &a)
{
  return pseudovector(pseudovector::coord_gamma_0gamma_1gamma_2_gamma_0gamma_1gamma_3_gamma_0gamma_2gamma_3_gamma_1gamma_2gamma_3,
      a.m_c[3], // gamma_0_gamma_1_gamma_2
      -a.m_c[2], // gamma_0_gamma_1_gamma_3
      a.m_c[1], // gamma_0_gamma_2_gamma_3
      a.m_c[0] // gamma_1_gamma_2_gamma_3
    );

}
inline bivector dual(const bivector &a)
{
  return bivector(bivector::coord_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a.m_c[5], // gamma_0_gamma_1
      -a.m_c[4], // gamma_0_gamma_2
      a.m_c[3], // gamma_0_gamma_3
      -a.m_c[2], // gamma_1_gamma_2
      a.m_c[1], // gamma_1_gamma_3
      -a.m_c[0] // gamma_2_gamma_3
    );

}
inline vector dual(const pseudovector &a)
{
  return vector(vector::coord_gamma_0_gamma_1_gamma_2_gamma_3,
      -a.m_c[3], // gamma_0
      -a.m_c[2], // gamma_1
      a.m_c[1], // gamma_2
      -a.m_c[0] // gamma_3
    );

}
inline spinor dual(const spinor &a)
{
  return spinor(spinor::coord_scalar_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_0gamma_1gamma_2gamma_3,
      a.m_c[7], // scalar
      a.m_c[6], // gamma_0_gamma_1
      -a.m_c[5], // gamma_0_gamma_2
      a.m_c[4], // gamma_0_gamma_3
      -a.m_c[3], // gamma_1_gamma_2
      a.m_c[2], // gamma_1_gamma_3
      -a.m_c[1], // gamma_2_gamma_3
      -a.m_c[0] // gamma_0_gamma_1_gamma_2_gamma_3
    );

}
inline mv3 negate(const mv3 &a)
{
  return mv3(mv3::coord_scalar_gamma_1_gamma_2_gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_1gamma_2gamma_3,
      -a.m_c[0], // scalar
      -a.m_c[1], // gamma_1
      -a.m_c[2], // gamma_2
      -a.m_c[3], // gamma_3
      -a.m_c[4], // gamma_1_gamma_2
      -a.m_c[5], // gamma_1_gamma_3
      -a.m_c[6], // gamma_2_gamma_3
      -a.m_c[7] // gamma_1_gamma_2_gamma_3
    );

}
inline vector negate(const vector &a)
{
  return vector(vector::coord_gamma_0_gamma_1_gamma_2_gamma_3,
      -a.m_c[0], // gamma_0
      -a.m_c[1], // gamma_1
      -a.m_c[2], // gamma_2
      -a.m_c[3] // gamma_3
    );

}
inline vector3 negate(const vector3 &a)
{
  return vector3(vector3::coord_gamma_1_gamma_2_gamma_3,
      -a.m_c[0], // gamma_1
      -a.m_c[1], // gamma_2
      -a.m_c[2] // gamma_3
    );

}
inline bivector negate(const bivector &a)
{
  return bivector(bivector::coord_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      -a.m_c[0], // gamma_0_gamma_1
      -a.m_c[1], // gamma_0_gamma_2
      -a.m_c[2], // gamma_0_gamma_3
      -a.m_c[3], // gamma_1_gamma_2
      -a.m_c[4], // gamma_1_gamma_3
      -a.m_c[5] // gamma_2_gamma_3
    );

}
inline bivector3 negate(const bivector3 &a)
{
  return bivector3(bivector3::coord_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      -a.m_c[0], // gamma_1_gamma_2
      -a.m_c[1], // gamma_1_gamma_3
      -a.m_c[2] // gamma_2_gamma_3
    );

}
inline pseudovector negate(const pseudovector &a)
{
  return pseudovector(pseudovector::coord_gamma_0gamma_1gamma_2_gamma_0gamma_1gamma_3_gamma_0gamma_2gamma_3_gamma_1gamma_2gamma_3,
      -a.m_c[0], // gamma_0_gamma_1_gamma_2
      -a.m_c[1], // gamma_0_gamma_1_gamma_3
      -a.m_c[2], // gamma_0_gamma_2_gamma_3
      -a.m_c[3] // gamma_1_gamma_2_gamma_3
    );

}
inline spinor negate(const spinor &a)
{
  return spinor(spinor::coord_scalar_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_0gamma_1gamma_2gamma_3,
      -a.m_c[0], // scalar
      -a.m_c[1], // gamma_0_gamma_1
      -a.m_c[2], // gamma_0_gamma_2
      -a.m_c[3], // gamma_0_gamma_3
      -a.m_c[4], // gamma_1_gamma_2
      -a.m_c[5], // gamma_1_gamma_3
      -a.m_c[6], // gamma_2_gamma_3
      -a.m_c[7] // gamma_0_gamma_1_gamma_2_gamma_3
    );

}
inline spinor3 negate(const spinor3 &a)
{
  return spinor3(spinor3::coord_scalar_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      -a.m_c[0], // scalar
      -a.m_c[1], // gamma_1_gamma_2
      -a.m_c[2], // gamma_1_gamma_3
      -a.m_c[3] // gamma_2_gamma_3
    );

}
inline mv3 reverse(const mv3 &a)
{
  return mv3(mv3::coord_scalar_gamma_1_gamma_2_gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_1gamma_2gamma_3,
      a.m_c[0], // scalar
      a.m_c[1], // gamma_1
      a.m_c[2], // gamma_2
      a.m_c[3], // gamma_3
      -a.m_c[4], // gamma_1_gamma_2
      -a.m_c[5], // gamma_1_gamma_3
      -a.m_c[6], // gamma_2_gamma_3
      -a.m_c[7] // gamma_1_gamma_2_gamma_3
    );

}
inline vector reverse(const vector &a)
{
  return vector(vector::coord_gamma_0_gamma_1_gamma_2_gamma_3,
      a.m_c[0], // gamma_0
      a.m_c[1], // gamma_1
      a.m_c[2], // gamma_2
      a.m_c[3] // gamma_3
    );

}
inline vector3 reverse(const vector3 &a)
{
  return vector3(vector3::coord_gamma_1_gamma_2_gamma_3,
      a.m_c[0], // gamma_1
      a.m_c[1], // gamma_2
      a.m_c[2] // gamma_3
    );

}
inline bivector reverse(const bivector &a)
{
  return bivector(bivector::coord_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      -a.m_c[0], // gamma_0_gamma_1
      -a.m_c[1], // gamma_0_gamma_2
      -a.m_c[2], // gamma_0_gamma_3
      -a.m_c[3], // gamma_1_gamma_2
      -a.m_c[4], // gamma_1_gamma_3
      -a.m_c[5] // gamma_2_gamma_3
    );

}
inline bivector3 reverse(const bivector3 &a)
{
  return bivector3(bivector3::coord_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      -a.m_c[0], // gamma_1_gamma_2
      -a.m_c[1], // gamma_1_gamma_3
      -a.m_c[2] // gamma_2_gamma_3
    );

}
inline pseudovector reverse(const pseudovector &a)
{
  return pseudovector(pseudovector::coord_gamma_0gamma_1gamma_2_gamma_0gamma_1gamma_3_gamma_0gamma_2gamma_3_gamma_1gamma_2gamma_3,
      -a.m_c[0], // gamma_0_gamma_1_gamma_2
      -a.m_c[1], // gamma_0_gamma_1_gamma_3
      -a.m_c[2], // gamma_0_gamma_2_gamma_3
      -a.m_c[3] // gamma_1_gamma_2_gamma_3
    );

}
inline spinor reverse(const spinor &a)
{
  return spinor(spinor::coord_scalar_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_0gamma_1gamma_2gamma_3,
      a.m_c[0], // scalar
      -a.m_c[1], // gamma_0_gamma_1
      -a.m_c[2], // gamma_0_gamma_2
      -a.m_c[3], // gamma_0_gamma_3
      -a.m_c[4], // gamma_1_gamma_2
      -a.m_c[5], // gamma_1_gamma_3
      -a.m_c[6], // gamma_2_gamma_3
      a.m_c[7] // gamma_0_gamma_1_gamma_2_gamma_3
    );

}
inline spinor3 reverse(const spinor3 &a)
{
  return spinor3(spinor3::coord_scalar_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a.m_c[0], // scalar
      -a.m_c[1], // gamma_1_gamma_2
      -a.m_c[2], // gamma_1_gamma_3
      -a.m_c[3] // gamma_2_gamma_3
    );

}
inline mv3 cliffordConjugate(const mv3 &a)
{
  return mv3(mv3::coord_scalar_gamma_1_gamma_2_gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_1gamma_2gamma_3,
      a.m_c[0], // scalar
      -a.m_c[1], // gamma_1
      -a.m_c[2], // gamma_2
      -a.m_c[3], // gamma_3
      -a.m_c[4], // gamma_1_gamma_2
      -a.m_c[5], // gamma_1_gamma_3
      -a.m_c[6], // gamma_2_gamma_3
      a.m_c[7] // gamma_1_gamma_2_gamma_3
    );

}
inline vector cliffordConjugate(const vector &a)
{
  return vector(vector::coord_gamma_0_gamma_1_gamma_2_gamma_3,
      -a.m_c[0], // gamma_0
      -a.m_c[1], // gamma_1
      -a.m_c[2], // gamma_2
      -a.m_c[3] // gamma_3
    );

}
inline vector3 cliffordConjugate(const vector3 &a)
{
  return vector3(vector3::coord_gamma_1_gamma_2_gamma_3,
      -a.m_c[0], // gamma_1
      -a.m_c[1], // gamma_2
      -a.m_c[2] // gamma_3
    );

}
inline bivector cliffordConjugate(const bivector &a)
{
  return bivector(bivector::coord_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      -a.m_c[0], // gamma_0_gamma_1
      -a.m_c[1], // gamma_0_gamma_2
      -a.m_c[2], // gamma_0_gamma_3
      -a.m_c[3], // gamma_1_gamma_2
      -a.m_c[4], // gamma_1_gamma_3
      -a.m_c[5] // gamma_2_gamma_3
    );

}
inline bivector3 cliffordConjugate(const bivector3 &a)
{
  return bivector3(bivector3::coord_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      -a.m_c[0], // gamma_1_gamma_2
      -a.m_c[1], // gamma_1_gamma_3
      -a.m_c[2] // gamma_2_gamma_3
    );

}
inline pseudovector cliffordConjugate(const pseudovector &a)
{
  return pseudovector(pseudovector::coord_gamma_0gamma_1gamma_2_gamma_0gamma_1gamma_3_gamma_0gamma_2gamma_3_gamma_1gamma_2gamma_3,
      a.m_c[0], // gamma_0_gamma_1_gamma_2
      a.m_c[1], // gamma_0_gamma_1_gamma_3
      a.m_c[2], // gamma_0_gamma_2_gamma_3
      a.m_c[3] // gamma_1_gamma_2_gamma_3
    );

}
inline spinor cliffordConjugate(const spinor &a)
{
  return spinor(spinor::coord_scalar_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_0gamma_1gamma_2gamma_3,
      a.m_c[0], // scalar
      -a.m_c[1], // gamma_0_gamma_1
      -a.m_c[2], // gamma_0_gamma_2
      -a.m_c[3], // gamma_0_gamma_3
      -a.m_c[4], // gamma_1_gamma_2
      -a.m_c[5], // gamma_1_gamma_3
      -a.m_c[6], // gamma_2_gamma_3
      a.m_c[7] // gamma_0_gamma_1_gamma_2_gamma_3
    );

}
inline spinor3 cliffordConjugate(const spinor3 &a)
{
  return spinor3(spinor3::coord_scalar_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a.m_c[0], // scalar
      -a.m_c[1], // gamma_1_gamma_2
      -a.m_c[2], // gamma_1_gamma_3
      -a.m_c[3] // gamma_2_gamma_3
    );

}
inline mv3 gradeInvolution(const mv3 &a)
{
  return mv3(mv3::coord_scalar_gamma_1_gamma_2_gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_1gamma_2gamma_3,
      a.m_c[0], // scalar
      -a.m_c[1], // gamma_1
      -a.m_c[2], // gamma_2
      -a.m_c[3], // gamma_3
      a.m_c[4], // gamma_1_gamma_2
      a.m_c[5], // gamma_1_gamma_3
      a.m_c[6], // gamma_2_gamma_3
      -a.m_c[7] // gamma_1_gamma_2_gamma_3
    );

}
inline vector gradeInvolution(const vector &a)
{
  return vector(vector::coord_gamma_0_gamma_1_gamma_2_gamma_3,
      -a.m_c[0], // gamma_0
      -a.m_c[1], // gamma_1
      -a.m_c[2], // gamma_2
      -a.m_c[3] // gamma_3
    );

}
inline vector3 gradeInvolution(const vector3 &a)
{
  return vector3(vector3::coord_gamma_1_gamma_2_gamma_3,
      -a.m_c[0], // gamma_1
      -a.m_c[1], // gamma_2
      -a.m_c[2] // gamma_3
    );

}
inline bivector gradeInvolution(const bivector &a)
{
  return bivector(bivector::coord_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a.m_c[0], // gamma_0_gamma_1
      a.m_c[1], // gamma_0_gamma_2
      a.m_c[2], // gamma_0_gamma_3
      a.m_c[3], // gamma_1_gamma_2
      a.m_c[4], // gamma_1_gamma_3
      a.m_c[5] // gamma_2_gamma_3
    );

}
inline bivector3 gradeInvolution(const bivector3 &a)
{
  return bivector3(bivector3::coord_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a.m_c[0], // gamma_1_gamma_2
      a.m_c[1], // gamma_1_gamma_3
      a.m_c[2] // gamma_2_gamma_3
    );

}
inline pseudovector gradeInvolution(const pseudovector &a)
{
  return pseudovector(pseudovector::coord_gamma_0gamma_1gamma_2_gamma_0gamma_1gamma_3_gamma_0gamma_2gamma_3_gamma_1gamma_2gamma_3,
      -a.m_c[0], // gamma_0_gamma_1_gamma_2
      -a.m_c[1], // gamma_0_gamma_1_gamma_3
      -a.m_c[2], // gamma_0_gamma_2_gamma_3
      -a.m_c[3] // gamma_1_gamma_2_gamma_3
    );

}
inline spinor gradeInvolution(const spinor &a)
{
  return spinor(spinor::coord_scalar_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_0gamma_1gamma_2gamma_3,
      a.m_c[0], // scalar
      a.m_c[1], // gamma_0_gamma_1
      a.m_c[2], // gamma_0_gamma_2
      a.m_c[3], // gamma_0_gamma_3
      a.m_c[4], // gamma_1_gamma_2
      a.m_c[5], // gamma_1_gamma_3
      a.m_c[6], // gamma_2_gamma_3
      a.m_c[7] // gamma_0_gamma_1_gamma_2_gamma_3
    );

}
inline spinor3 gradeInvolution(const spinor3 &a)
{
  return spinor3(spinor3::coord_scalar_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a.m_c[0], // scalar
      a.m_c[1], // gamma_1_gamma_2
      a.m_c[2], // gamma_1_gamma_3
      a.m_c[3] // gamma_2_gamma_3
    );

}
inline double norm_returns_scalar(const mv &a) {
  return norm(a);
}
inline double norm(const mv3 &a)
{
  return ::fabs(::sqrt(::fabs((a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3]+a.m_c[4]*a.m_c[4]+a.m_c[5]*a.m_c[5]+a.m_c[6]*a.m_c[6]+a.m_c[7]*a.m_c[7]))));

}
inline double norm_returns_scalar(const mv3 &a) {
  return norm(a);
}
inline double norm(const vector &a)
{
  return ::fabs(::sqrt(::fabs((-a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3]))));

}
inline double norm_returns_scalar(const vector &a) {
  return norm(a);
}
inline double norm(const vector3 &a)
{
  return ::fabs(::sqrt(::fabs((a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]))));

}
inline double norm_returns_scalar(const vector3 &a) {
  return norm(a);
}
inline double norm(const bivector &a)
{
  return ::fabs(::sqrt(::fabs((-a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3]+a.m_c[4]*a.m_c[4]+a.m_c[5]*a.m_c[5]))));

}
inline double norm_returns_scalar(const bivector &a) {
  return norm(a);
}
inline double norm(const bivector3 &a)
{
  return ::fabs(::sqrt(::fabs((a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]))));

}
inline double norm_returns_scalar(const bivector3 &a) {
  return norm(a);
}
inline double norm(const pseudovector &a)
{
  return ::fabs(::sqrt(::fabs((-a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3]))));

}
inline double norm_returns_scalar(const pseudovector &a) {
  return norm(a);
}
inline double norm(const spinor &a)
{
  return ::fabs(::sqrt(::fabs((a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]-a.m_c[3]*a.m_c[3]+a.m_c[4]*a.m_c[4]+a.m_c[5]*a.m_c[5]+a.m_c[6]*a.m_c[6]-a.m_c[7]*a.m_c[7]))));

}
inline double norm_returns_scalar(const spinor &a) {
  return norm(a);
}
inline double norm(const spinor3 &a)
{
  return ::fabs(::sqrt(::fabs((a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3]))));

}
inline double norm_returns_scalar(const spinor3 &a) {
  return norm(a);
}
inline double norm2_returns_scalar(const mv &a) {
  return norm2(a);
}
inline double norm2(const mv3 &a)
{
  return (a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3]+a.m_c[4]*a.m_c[4]+a.m_c[5]*a.m_c[5]+a.m_c[6]*a.m_c[6]+a.m_c[7]*a.m_c[7]);

}
inline double norm2_returns_scalar(const mv3 &a) {
  return norm2(a);
}
inline double norm2(const vector &a)
{
  return (-a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3]);

}
inline double norm2_returns_scalar(const vector &a) {
  return norm2(a);
}
inline double norm2(const vector3 &a)
{
  return (a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]);

}
inline double norm2_returns_scalar(const vector3 &a) {
  return norm2(a);
}
inline double norm2(const bivector &a)
{
  return (-a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3]+a.m_c[4]*a.m_c[4]+a.m_c[5]*a.m_c[5]);

}
inline double norm2_returns_scalar(const bivector &a) {
  return norm2(a);
}
inline double norm2(const bivector3 &a)
{
  return (a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]);

}
inline double norm2_returns_scalar(const bivector3 &a) {
  return norm2(a);
}
inline double norm2(const pseudovector &a)
{
  return (-a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3]);

}
inline double norm2_returns_scalar(const pseudovector &a) {
  return norm2(a);
}
inline double norm2(const spinor &a)
{
  return (a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]-a.m_c[3]*a.m_c[3]+a.m_c[4]*a.m_c[4]+a.m_c[5]*a.m_c[5]+a.m_c[6]*a.m_c[6]-a.m_c[7]*a.m_c[7]);

}
inline double norm2_returns_scalar(const spinor &a) {
  return norm2(a);
}
inline double norm2(const spinor3 &a)
{
  return (a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3]);

}
inline double norm2_returns_scalar(const spinor3 &a) {
  return norm2(a);
}
inline double norm2_euclidean_returns_scalar(const mv &a) {
  return norm2_euclidean(a);
}
inline mv3 unit(const mv3 &a)
{
  double _n_ = ::sqrt(::fabs((a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3]+a.m_c[4]*a.m_c[4]+a.m_c[5]*a.m_c[5]+a.m_c[6]*a.m_c[6]+a.m_c[7]*a.m_c[7])));

  return mv3(mv3::coord_scalar_gamma_1_gamma_2_gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_1gamma_2gamma_3,
      a.m_c[0]/((_n_)), // scalar
      a.m_c[1]/((_n_)), // gamma_1
      a.m_c[2]/((_n_)), // gamma_2
      a.m_c[3]/((_n_)), // gamma_3
      a.m_c[4]/((_n_)), // gamma_1_gamma_2
      a.m_c[5]/((_n_)), // gamma_1_gamma_3
      a.m_c[6]/((_n_)), // gamma_2_gamma_3
      a.m_c[7]/((_n_)) // gamma_1_gamma_2_gamma_3
    );
}
inline vector unit(const vector &a)
{
  double _n_ = ::sqrt(::fabs((-a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3])));

  return vector(vector::coord_gamma_0_gamma_1_gamma_2_gamma_3,
      a.m_c[0]/((_n_)), // gamma_0
      a.m_c[1]/((_n_)), // gamma_1
      a.m_c[2]/((_n_)), // gamma_2
      a.m_c[3]/((_n_)) // gamma_3
    );
}
inline vector3 unit(const vector3 &a)
{
  double _n_ = ::sqrt(::fabs((a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2])));

  return vector3(vector3::coord_gamma_1_gamma_2_gamma_3,
      a.m_c[0]/((_n_)), // gamma_1
      a.m_c[1]/((_n_)), // gamma_2
      a.m_c[2]/((_n_)) // gamma_3
    );
}
inline bivector unit(const bivector &a)
{
  double _n_ = ::sqrt(::fabs((-a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3]+a.m_c[4]*a.m_c[4]+a.m_c[5]*a.m_c[5])));

  return bivector(bivector::coord_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a.m_c[0]/((_n_)), // gamma_0_gamma_1
      a.m_c[1]/((_n_)), // gamma_0_gamma_2
      a.m_c[2]/((_n_)), // gamma_0_gamma_3
      a.m_c[3]/((_n_)), // gamma_1_gamma_2
      a.m_c[4]/((_n_)), // gamma_1_gamma_3
      a.m_c[5]/((_n_)) // gamma_2_gamma_3
    );
}
inline bivector3 unit(const bivector3 &a)
{
  double _n_ = ::sqrt(::fabs((a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2])));

  return bivector3(bivector3::coord_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a.m_c[0]/((_n_)), // gamma_1_gamma_2
      a.m_c[1]/((_n_)), // gamma_1_gamma_3
      a.m_c[2]/((_n_)) // gamma_2_gamma_3
    );
}
inline pseudovector unit(const pseudovector &a)
{
  double _n_ = ::sqrt(::fabs((-a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3])));

  return pseudovector(pseudovector::coord_gamma_0gamma_1gamma_2_gamma_0gamma_1gamma_3_gamma_0gamma_2gamma_3_gamma_1gamma_2gamma_3,
      a.m_c[0]/((_n_)), // gamma_0_gamma_1_gamma_2
      a.m_c[1]/((_n_)), // gamma_0_gamma_1_gamma_3
      a.m_c[2]/((_n_)), // gamma_0_gamma_2_gamma_3
      a.m_c[3]/((_n_)) // gamma_1_gamma_2_gamma_3
    );
}
inline spinor unit(const spinor &a)
{
  double _n_ = ::sqrt(::fabs((a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]-a.m_c[3]*a.m_c[3]+a.m_c[4]*a.m_c[4]+a.m_c[5]*a.m_c[5]+a.m_c[6]*a.m_c[6]-a.m_c[7]*a.m_c[7])));

  return spinor(spinor::coord_scalar_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_0gamma_1gamma_2gamma_3,
      a.m_c[0]/((_n_)), // scalar
      a.m_c[1]/((_n_)), // gamma_0_gamma_1
      a.m_c[2]/((_n_)), // gamma_0_gamma_2
      a.m_c[3]/((_n_)), // gamma_0_gamma_3
      a.m_c[4]/((_n_)), // gamma_1_gamma_2
      a.m_c[5]/((_n_)), // gamma_1_gamma_3
      a.m_c[6]/((_n_)), // gamma_2_gamma_3
      a.m_c[7]/((_n_)) // gamma_0_gamma_1_gamma_2_gamma_3
    );
}
inline spinor3 unit(const spinor3 &a)
{
  double _n_ = ::sqrt(::fabs((a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3])));

  return spinor3(spinor3::coord_scalar_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a.m_c[0]/((_n_)), // scalar
      a.m_c[1]/((_n_)), // gamma_1_gamma_2
      a.m_c[2]/((_n_)), // gamma_1_gamma_3
      a.m_c[3]/((_n_)) // gamma_2_gamma_3
    );
}
inline spinor3 versorInverse(const spinor3 &a)
{
  double _n2_ = (a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3]);

  return spinor3(spinor3::coord_scalar_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      a.m_c[0]/((_n2_)), // scalar
      -a.m_c[1]/((_n2_)), // gamma_1_gamma_2
      -a.m_c[2]/((_n2_)), // gamma_1_gamma_3
      -a.m_c[3]/((_n2_)) // gamma_2_gamma_3
    );
}
inline spinor versorInverse(const spinor &a)
{
  double _n2_ = (a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]-a.m_c[3]*a.m_c[3]+a.m_c[4]*a.m_c[4]+a.m_c[5]*a.m_c[5]+a.m_c[6]*a.m_c[6]-a.m_c[7]*a.m_c[7]);

  return spinor(spinor::coord_scalar_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_0gamma_1gamma_2gamma_3,
      a.m_c[0]/((_n2_)), // scalar
      -a.m_c[1]/((_n2_)), // gamma_0_gamma_1
      -a.m_c[2]/((_n2_)), // gamma_0_gamma_2
      -a.m_c[3]/((_n2_)), // gamma_0_gamma_3
      -a.m_c[4]/((_n2_)), // gamma_1_gamma_2
      -a.m_c[5]/((_n2_)), // gamma_1_gamma_3
      -a.m_c[6]/((_n2_)), // gamma_2_gamma_3
      a.m_c[7]/((_n2_)) // gamma_0_gamma_1_gamma_2_gamma_3
    );
}
inline spinor3 sas(const spinor3 &a, const double b, const double c)
{
  return spinor3(spinor3::coord_scalar_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
      (a.m_c[0]*b+c), // scalar
      a.m_c[1]*b, // gamma_1_gamma_2
      a.m_c[2]*b, // gamma_1_gamma_3
      a.m_c[3]*b // gamma_2_gamma_3
    );
}
inline spinor sas(const spinor &a, const double b, const double c)
{
  return spinor(spinor::coord_scalar_gamma_0gamma_1_gamma_0gamma_2_gamma_0gamma_3_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3_gamma_0gamma_1gamma_2gamma_3,
      (a.m_c[0]*b+c), // scalar
      a.m_c[1]*b, // gamma_0_gamma_1
      a.m_c[2]*b, // gamma_0_gamma_2
      a.m_c[3]*b, // gamma_0_gamma_3
      a.m_c[4]*b, // gamma_1_gamma_2
      a.m_c[5]*b, // gamma_1_gamma_3
      a.m_c[6]*b, // gamma_2_gamma_3
      a.m_c[7]*b // gamma_0_gamma_1_gamma_2_gamma_3
    );
}
inline bivector3 log(const mv3 &a)
{
  double _g2norm2_ = (a.m_c[4]*a.m_c[4]+a.m_c[5]*a.m_c[5]+a.m_c[6]*a.m_c[6]);

  double _scalarPart_ = a.m_c[0];

  if (_g2norm2_ <= 0.0) {
    if (_scalarPart_ < 0.0) {
      return bivector3(bivector3::coord_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
          3.1415926535897931, // gamma_1_gamma_2
          0.0, // gamma_1_gamma_3
          0.0 // gamma_2_gamma_3
        );
    }
    else {
      return bivector3(bivector3::coord_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
          0.0, // gamma_1_gamma_2
          0.0, // gamma_1_gamma_3
          0.0 // gamma_2_gamma_3
        );
    }
  }
  else {
    double _g2norm_ = ::sqrt(_g2norm2_);

    double _mul_ = (::atan2(_g2norm_, _scalarPart_))/(_g2norm_);

    return bivector3(bivector3::coord_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
        _mul_*a.m_c[4], // gamma_1_gamma_2
        _mul_*a.m_c[5], // gamma_1_gamma_3
        _mul_*a.m_c[6] // gamma_2_gamma_3
      );
  }
}
inline bivector3 log(const spinor3 &a)
{
  double _g2norm2_ = (a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3]);

  double _scalarPart_ = a.m_c[0];

  if (_g2norm2_ <= 0.0) {
    if (_scalarPart_ < 0.0) {
      return bivector3(bivector3::coord_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
          3.1415926535897931, // gamma_1_gamma_2
          0.0, // gamma_1_gamma_3
          0.0 // gamma_2_gamma_3
        );
    }
    else {
      return bivector3(bivector3::coord_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
          0.0, // gamma_1_gamma_2
          0.0, // gamma_1_gamma_3
          0.0 // gamma_2_gamma_3
        );
    }
  }
  else {
    double _g2norm_ = ::sqrt(_g2norm2_);

    double _mul_ = (::atan2(_g2norm_, _scalarPart_))/(_g2norm_);

    return bivector3(bivector3::coord_gamma_1gamma_2_gamma_1gamma_3_gamma_2gamma_3,
        _mul_*a.m_c[1], // gamma_1_gamma_2
        _mul_*a.m_c[2], // gamma_1_gamma_3
        _mul_*a.m_c[3] // gamma_2_gamma_3
      );
  }
}
inline vector applyVersor(const spinor &R, const vector &v)
{
  double _n2_ = (R.m_c[0]*R.m_c[0]-R.m_c[1]*R.m_c[1]-R.m_c[2]*R.m_c[2]-R.m_c[3]*R.m_c[3]+R.m_c[4]*R.m_c[4]+R.m_c[5]*R.m_c[5]+R.m_c[6]*R.m_c[6]-R.m_c[7]*R.m_c[7]);

  return vector(vector::coord_gamma_0_gamma_1_gamma_2_gamma_3,
      ((R.m_c[0]*R.m_c[0]*v.m_c[0]+2.0*R.m_c[0]*R.m_c[1]*v.m_c[1]+2.0*R.m_c[0]*R.m_c[2]*v.m_c[2]+2.0*R.m_c[0]*R.m_c[3]*v.m_c[3]+R.m_c[1]*R.m_c[1]*v.m_c[0]+2.0*R.m_c[1]*R.m_c[4]*v.m_c[2]+2.0*R.m_c[1]*R.m_c[5]*v.m_c[3]+R.m_c[2]*R.m_c[2]*v.m_c[0]+-2.0*R.m_c[2]*R.m_c[4]*v.m_c[1]+2.0*R.m_c[2]*R.m_c[6]*v.m_c[3]+R.m_c[3]*R.m_c[3]*v.m_c[0]+-2.0*R.m_c[3]*R.m_c[5]*v.m_c[1]+-2.0*R.m_c[3]*R.m_c[6]*v.m_c[2]+R.m_c[4]*R.m_c[4]*v.m_c[0]+2.0*R.m_c[4]*R.m_c[7]*v.m_c[3]+R.m_c[5]*R.m_c[5]*v.m_c[0]+-2.0*R.m_c[5]*R.m_c[7]*v.m_c[2]+R.m_c[6]*R.m_c[6]*v.m_c[0]+2.0*R.m_c[6]*R.m_c[7]*v.m_c[1]+R.m_c[7]*R.m_c[7]*v.m_c[0]))/(_n2_), // gamma_0
      ((R.m_c[0]*R.m_c[0]*v.m_c[1]+2.0*R.m_c[0]*R.m_c[1]*v.m_c[0]+2.0*R.m_c[0]*R.m_c[4]*v.m_c[2]+2.0*R.m_c[0]*R.m_c[5]*v.m_c[3]+R.m_c[1]*R.m_c[1]*v.m_c[1]+2.0*R.m_c[1]*R.m_c[2]*v.m_c[2]+2.0*R.m_c[1]*R.m_c[3]*v.m_c[3]-R.m_c[2]*R.m_c[2]*v.m_c[1]+2.0*R.m_c[2]*R.m_c[4]*v.m_c[0]+2.0*R.m_c[2]*R.m_c[7]*v.m_c[3]-R.m_c[3]*R.m_c[3]*v.m_c[1]+2.0*R.m_c[3]*R.m_c[5]*v.m_c[0]+-2.0*R.m_c[3]*R.m_c[7]*v.m_c[2]-R.m_c[4]*R.m_c[4]*v.m_c[1]+2.0*R.m_c[4]*R.m_c[6]*v.m_c[3]-R.m_c[5]*R.m_c[5]*v.m_c[1]+-2.0*R.m_c[5]*R.m_c[6]*v.m_c[2]+R.m_c[6]*R.m_c[6]*v.m_c[1]+2.0*R.m_c[6]*R.m_c[7]*v.m_c[0]+R.m_c[7]*R.m_c[7]*v.m_c[1]))/(_n2_), // gamma_1
      ((R.m_c[0]*R.m_c[0]*v.m_c[2]+2.0*R.m_c[0]*R.m_c[2]*v.m_c[0]+-2.0*R.m_c[0]*R.m_c[4]*v.m_c[1]+2.0*R.m_c[0]*R.m_c[6]*v.m_c[3]-R.m_c[1]*R.m_c[1]*v.m_c[2]+2.0*R.m_c[1]*R.m_c[2]*v.m_c[1]+-2.0*R.m_c[1]*R.m_c[4]*v.m_c[0]+-2.0*R.m_c[1]*R.m_c[7]*v.m_c[3]+R.m_c[2]*R.m_c[2]*v.m_c[2]+2.0*R.m_c[2]*R.m_c[3]*v.m_c[3]-R.m_c[3]*R.m_c[3]*v.m_c[2]+2.0*R.m_c[3]*R.m_c[6]*v.m_c[0]+2.0*R.m_c[3]*R.m_c[7]*v.m_c[1]-R.m_c[4]*R.m_c[4]*v.m_c[2]+-2.0*R.m_c[4]*R.m_c[5]*v.m_c[3]+R.m_c[5]*R.m_c[5]*v.m_c[2]+-2.0*R.m_c[5]*R.m_c[6]*v.m_c[1]+-2.0*R.m_c[5]*R.m_c[7]*v.m_c[0]-R.m_c[6]*R.m_c[6]*v.m_c[2]+R.m_c[7]*R.m_c[7]*v.m_c[2]))/(_n2_), // gamma_2
      ((R.m_c[0]*R.m_c[0]*v.m_c[3]+2.0*R.m_c[0]*R.m_c[3]*v.m_c[0]+-2.0*R.m_c[0]*R.m_c[5]*v.m_c[1]+-2.0*R.m_c[0]*R.m_c[6]*v.m_c[2]-R.m_c[1]*R.m_c[1]*v.m_c[3]+2.0*R.m_c[1]*R.m_c[3]*v.m_c[1]+-2.0*R.m_c[1]*R.m_c[5]*v.m_c[0]+2.0*R.m_c[1]*R.m_c[7]*v.m_c[2]-R.m_c[2]*R.m_c[2]*v.m_c[3]+2.0*R.m_c[2]*R.m_c[3]*v.m_c[2]+-2.0*R.m_c[2]*R.m_c[6]*v.m_c[0]+-2.0*R.m_c[2]*R.m_c[7]*v.m_c[1]+R.m_c[3]*R.m_c[3]*v.m_c[3]+R.m_c[4]*R.m_c[4]*v.m_c[3]+-2.0*R.m_c[4]*R.m_c[5]*v.m_c[2]+2.0*R.m_c[4]*R.m_c[6]*v.m_c[1]+2.0*R.m_c[4]*R.m_c[7]*v.m_c[0]-R.m_c[5]*R.m_c[5]*v.m_c[3]-R.m_c[6]*R.m_c[6]*v.m_c[3]+R.m_c[7]*R.m_c[7]*v.m_c[3]))/(_n2_) // gamma_3
    );
}
inline vector3 applyUnitVersor(const spinor3 &R, const vector3 &v)
{
  return vector3(vector3::coord_gamma_1_gamma_2_gamma_3,
      (R.m_c[0]*R.m_c[0]*v.m_c[0]+2.0*R.m_c[0]*R.m_c[1]*v.m_c[1]+2.0*R.m_c[0]*R.m_c[2]*v.m_c[2]-R.m_c[1]*R.m_c[1]*v.m_c[0]+2.0*R.m_c[1]*R.m_c[3]*v.m_c[2]-R.m_c[2]*R.m_c[2]*v.m_c[0]+-2.0*R.m_c[2]*R.m_c[3]*v.m_c[1]+R.m_c[3]*R.m_c[3]*v.m_c[0]), // gamma_1
      (R.m_c[0]*R.m_c[0]*v.m_c[1]+-2.0*R.m_c[0]*R.m_c[1]*v.m_c[0]+2.0*R.m_c[0]*R.m_c[3]*v.m_c[2]-R.m_c[1]*R.m_c[1]*v.m_c[1]+-2.0*R.m_c[1]*R.m_c[2]*v.m_c[2]+R.m_c[2]*R.m_c[2]*v.m_c[1]+-2.0*R.m_c[2]*R.m_c[3]*v.m_c[0]-R.m_c[3]*R.m_c[3]*v.m_c[1]), // gamma_2
      (R.m_c[0]*R.m_c[0]*v.m_c[2]+-2.0*R.m_c[0]*R.m_c[2]*v.m_c[0]+-2.0*R.m_c[0]*R.m_c[3]*v.m_c[1]+R.m_c[1]*R.m_c[1]*v.m_c[2]+-2.0*R.m_c[1]*R.m_c[2]*v.m_c[1]+2.0*R.m_c[1]*R.m_c[3]*v.m_c[0]-R.m_c[2]*R.m_c[2]*v.m_c[2]-R.m_c[3]*R.m_c[3]*v.m_c[2]) // gamma_3
    );
}


/** structure used by custom parser */
struct SpacetimeAlgebraParseMultivectorData {
  /** the parsed value */
  mv value;
  /** this string will contain an error message when error is true */
  char message[256];
};

/**
Parses 'str' (output of toString_mv()) and stores result in 'val'
Throws std::string on error.
*/
mv parse(const std::string &str);

/**
Parses 'str' (output of toString_mv()) and stores result in 'data'.
'strSourceName' is the name of the source of 'str' (for example, a filename).
It is used for error messages.

  Returns true when 'str' parsed correctly.
Otherwise a lexer or parser error occured and you can check
the errors in 'data->message'.
*/
bool parseEx(struct SpacetimeAlgebraParseMultivectorData &data, const std::string &str, const std::string &strSourceName);
} // end of namespace SpacetimeAlgebra
#endif /* _SPACETIMEALGEBRA_H_ */
